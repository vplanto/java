# Практикум 2: Класи, Інтерфейси та Наслідування в Java

## Вступ

У цьому практикумі ми розглянемо три фундаментальні концепції ООП: **класи**, **інтерфейси** та **наслідування**. Ми також розберемося, як працюють модифікатори доступу `public`, `private` та `protected` для керування видимістю даних та методів.

---

## Частина 1: Клас — креслення для об'єктів

**Клас** — це шаблон або креслення, за яким створюються об'єкти. Він описує, які **властивості (поля)** та **поведінку (методи)** матимуть ці об'єкти.

* **`private`**: Поля, позначені як `private`, доступні **тільки всередині** самого класу. Це основний інструмент **інкапсуляції**, який захищає дані від прямого неконтрольованого доступу.
* **`public`**: Методи та конструктори, позначені як `public`, доступні **з будь-якого іншого класу**. Через них ми надаємо контрольований доступ до `private`-полів.

**Приклад: Клас `Car`**
```java
// Car.java
public class Car {
    private String model; // Доступно тільки всередині класу Car
    protected int maxSpeed; // Доступно для нащадків (детальніше далі)

    // Конструктор для створення об'єкта
    public Car(String model, int maxSpeed) {
        this.model = model;
        this.maxSpeed = maxSpeed;
    }

    // "Геттер" - публічний метод для отримання значення private-поля
    public String getModel() {
        return model;
    }

    // Публічний метод, що описує поведінку
    public void startEngine() {
        System.out.println("Двигун автомобіля " + model + " запущено.");
    }
}
````

-----

## Частина 2: Наслідування — відношення "є"

**Наслідування** дозволяє створити новий клас (нащадок) на основі вже існуючого (батьківського). Нащадок "успадковує" всі публічні та захищені поля і методи батьківського класу.

  * **`protected`**: Поля та методи, позначені як `protected`, доступні всередині свого класу, а також **для всіх класів-нащадків**.

**Приклад: Клас `Truck` є різновидом `Car`**

```java
// Truck.java
public class Truck extends Car { // Truck "є" Car
    private double cargoCapacity;

    public Truck(String model, int maxSpeed, double cargoCapacity) {
        super(model, maxSpeed); // Виклик конструктора батьківського класу Car
        this.cargoCapacity = cargoCapacity;
    }

    public void loadCargo() {
        // Ми можемо напряму звернутися до protected-поля maxSpeed
        System.out.println("Завантажуємо вантаж. Максимальна швидкість вантажівки: " + maxSpeed + " км/год.");
    }
}
```

-----

## Частина 3: Інтерфейс — контракт на поведінку

**Інтерфейс** — це, по суті, "контракт", який визначає набір методів, що клас **зобов'язаний** реалізувати. Інтерфейс описує *що* клас повинен робити, але не *як* саме.

**Приклад: Інтерфейс `Drivable`**

```java
// Drivable.java
public interface Drivable {
    // Будь-який клас, що реалізує цей інтерфейс,
    // ЗОБОВ'ЯЗАНИЙ мати метод drive()
    void drive();
}
```

Тепер "навчимо" наш клас `Car` реалізовувати цей контракт.

```java
// Змінюємо клас Car
public class Car implements Drivable {
    // ... (попередній код класу) ...

    @Override // Анотація показує, що ми реалізуємо метод з інтерфейсу
    public void drive() {
        System.out.println(model + " їде по дорозі.");
    }
}
```

-----

### Частина 4: Абстрактні класи — часткова реалізація

Іноді нам потрібно створити базовий клас, який містить **часткову реалізацію**, але сам по собі не є повноцінним об'єктом. Для цього існують **абстрактні класи**.

**Абстрактний клас** — це клас, який не може мати екземплярів (не можна створити об'єкт `new AbstractClass()`). Він може містити як звичайні (реалізовані) методи, так і **абстрактні методи** — методи без реалізації, які нащадки **зобов'язані** перевизначити.

  * **Коли використовувати:** Коли ви хочете створити спільну базу для групи пов'язаних класів, надавши їм готову функціональність, але змусивши реалізувати деякі специфічні деталі.

**Приклад: Абстрактний клас `Vehicle`**

```java
// Vehicle.java (абстрактний клас)
public abstract class Vehicle {
    protected String brand;

    public Vehicle(String brand) {
        this.brand = brand;
    }

    // Звичайний, реалізований метод, спільний для всіх нащадків
    public String getBrand() {
        return brand;
    }

    // Абстрактний метод - без тіла.
    // Кожен нащадок ЗОБОВ'ЯЗАНИЙ надати свою реалізацію.
    public abstract void move();
}

// Car.java (конкретний клас)
public class Car extends Vehicle {
    public Car(String brand) {
        super(brand);
    }

    @Override
    public void move() {
        System.out.println("Автомобіль " + brand + " їде по дорозі.");
    }
}
```

-----

### Частина 5: Інтерфейс, Абстрактний клас чи Клас — що обрати?

Правильний вибір між цими трьома конструкціями є ключем до гнучкої архітектури.

| Критерій | **Інтерфейс** | **Абстрактний клас** | **Конкретний клас** |
| :--- | :--- | :--- | :--- |
| **Призначення** | Описує **поведінку** ("Що робить?"). Це контракт. | Описує **спільну ідентичність** та **часткову реалізацію**. | Описує **конкретну сутність**. Готовий до створення об'єктів. |
| **Методи** | Тільки абстрактні (до Java 8). | Може мати і абстрактні, і реалізовані методи. | Тільки реалізовані методи. |
| **Поля** | Тільки `public static final` константи. | Може мати будь-які поля (включаючи `private`). | Може мати будь-які поля. |
| **Наслідування** | Клас може **реалізовувати (`implements`) багато** інтерфейсів. | Клас може **успадковувати (`extends`) лише один** клас (абстрактний чи ні). | Клас може успадковувати лише один клас. |
| **Коли обирати** | Коли потрібно описати спільну поведінку для **неспоріднених** класів (напр., і `Car`, і `Bird` можуть реалізувати `Movable`). | Коли потрібно створити **спільну базу для групи споріднених** класів, надавши їм готову функціональність (напр., `Car` та `Truck` є `Vehicle`). | Коли вам потрібен готовий шаблон для створення об'єктів. |

-----

### \#\# Порівняння з C++

Концепція абстракції існує і в C++, але реалізується за допомогою іншого синтаксису.

#### Абстрактні класи в C++

У C++ немає ключового слова `abstract`. Клас стає абстрактним, якщо він має хоча б один **чисто віртуальний метод (pure virtual function)**.

  * **Віртуальний метод (`virtual`)**: Метод, який може бути перевизначений у класах-нащадках.
  * **Чисто віртуальний метод (`= 0`)**: Метод, для якого **немає реалізації** в базовому класі. Нащадок **зобов'язаний** його реалізувати.

**Приклад, аналогічний до Java:**

```cpp
// vehicle.h
class Vehicle {
protected:
    std::string brand;

public:
    Vehicle(std::string brand) : brand(brand) {}

    // Звичайний метод
    std::string getBrand() {
        return brand;
    }

    // Чисто віртуальний метод. Робить клас Vehicle абстрактним.
    virtual void move() = 0;

    // Віртуальний деструктор (обов'язковий для базових класів з віртуальними методами)
    virtual ~Vehicle() {}
};

// car.h
class Car : public Vehicle {
public:
    Car(std::string brand) : Vehicle(brand) {}

    // Перевизначення (реалізація) чисто віртуального методу
    void move() override {
        std::cout << "Автомобіль " << brand << " їде по дорозі." << std::endl;
    }
};
```

#### Ключові відмінності C++ від Java

| Аспект | **Java** | **C++** |
| :--- | :--- | :--- |
| **Ключові слова** | `abstract`, `implements`, `extends` | `virtual`, `= 0` (для чистоти), `override` (рекомендовано) |
| **Множинне наслідування** | **Заборонено.** Клас може успадкувати лише один клас (абстрактний чи ні). | **Дозволено.** Клас може успадковувати декілька абстрактних класів. |
| **Інтерфейси** | Є окремою сутністю (`interface`). | Немає. Еквівалент інтерфейсу — це абстрактний клас, що містить **тільки** чисто віртуальні методи. |

-----

## Контрольні питання

1.  **Інкапсуляція.** Чому поля класу прийнято оголошувати як `private`, а доступ до них надавати через `public` геттери та сеттери?
2.  **Наслідування.** Уявіть, що клас `Truck` (нащадок) намагається напряму звернутися до `private`-поля `model` з класу `Car` (батьківського). Чи вдасться це зробити і чому? Який модифікатор доступу потрібно було б використати для `model`, щоб це стало можливим?
3.  **Поліморфізм.** Що буде виведено на екран в результаті виконання наступного коду?
    ```java
    Car myCar = new Car("Sedan", 180);
    Drivable myTruck = new Truck("Volvo", 120, 20.5);

    myCar.drive();
    myTruck.drive(); // Чому цей виклик можливий?
    ```
4.  **Інтерфейси.** Чи може один клас реалізовувати декілька інтерфейсів одночасно? Наведіть гіпотетичний приклад.

5.  **Інтерфейси vs. Абстрактні класи.** У вас є класи `Dog`, `Cat`, `Fish`. Всі вони мають спільну логіку (наприклад, поле `age`), але рухаються по-різному. Що ви оберете як базову сутність — інтерфейс `Animal` чи абстрактний клас `Animal`? Обґрунтуйте свій вибір.
6.  **Порівняння з C++.** Яка конструкція в C++ є еквівалентом абстрактного методу в Java?