# Лекція 4: Обробка винятків в Java

## ⚡ Експрес-опитування: Активація знань

На попередніх заняттях ми вже стикалися з помилками:

1.  Що станеться, якщо ви спробуєте отримати 10-й елемент з `ArrayList`, в якому всього 5 елементів?
2.  Що станеться, якщо ви викличете метод об'єкта, але сам об'єкт `null`?
3.  У [Лекції 1](01_what_is_java.md) ми бачили, що Java має `StackOverflowError`. Чим ця помилка, на вашу думку, відрізняється від звичайних помилок, як-от "неправильний індекс масиву"?

<details markdown="1">
<summary>Наші очікування (відповідь)</summary>

1.  Програма "впаде" з помилкою `ArrayIndexOutOfBoundsException`.
2.  Програма "впаде" з помилкою `NullPointerException`.
3.  `StackOverflowError` — це **критична** помилка самої JVM, яку ми не можемо (і не повинні) обробляти. А `ArrayIndexOutOfBoundsException` — це помилка логіки нашої програми, яку ми *могли б* передбачити та обробити.

</details>

Сьогодні ми детально розберемо цю різницю і навчимося писати код, який не "падає", а коректно реагує на нештатні ситуації.

## Що таке виняток?

**Виняток (Exception)** в Java — це небажана або неочікувана подія, яка виникає під час виконання програми (в runtime) і порушує її нормальний потік інструкцій. Механізм обробки винятків дозволяє коректно реагувати на такі помилки часу виконання, зберігаючи стабільність роботи додатку.

Коли в методі виникає виняткова ситуація, створюється спеціальний об'єкт, який називається **об'єктом винятку**. Цей об'єкт містить детальну інформацію про помилку: її ім'я, опис та стан програми на момент виникнення.

**Основні причини виникнення винятків:**

  * **Зовнішні фактори:**
      * Некоректні дані, введені користувачем.
      * Збій у роботі пристрою (наприклад, диска).
      * Втрата мережевого з'єднання.
      * Фізичні обмеження (недостатньо пам'яті на диску).
  * **Помилки в коді:**
      * Вихід за межі масиву (`ArrayIndexOutOfBoundsException`).
      * Звернення до об'єкта за `null`-посиланням (`NullPointerException`).
      * Неправильне приведення типів (`ClassCastException`).
      * Арифметичні помилки (ділення на нуль).
      * Спроба відкрити файл, що не існує.

-----

## Ієрархія винятків: `Throwable`, `Error` та `Exception`

Усі помилки та винятки в Java наслідуються від класу `Throwable`. Цей клас має два основних нащадки: `Error` та `Exception`.

![Ієрархія винятків](attachments/04_exceptions_hierarchy.png)

#### `Error`

Клас `Error` представляє **критичні, невідновлювані помилки**, які зазвичай виникають у самій JVM. Додаток не повинен намагатися їх перехоплювати чи обробляти.

  * **Приклади:** `OutOfMemoryError` (не вистачає пам'яті), `StackOverflowError` (переповнення стеку через нескінченну рекурсію), `VirtualMachineError`.

#### `Exception`

Клас `Exception` представляє умови, які додаток **може і повинен** намагатися обробити. Ці винятки, в свою чергу, поділяються на дві великі категорії.

-----

## Типи винятків: Checked vs. Unchecked

![Типи винятків](attachments/04_checked_unchecked.png)

#### Checked Exceptions (Перевірювані винятки)

  * Це винятки, які **перевіряються компілятором**.
  * Якщо метод може кинути такий виняток, він **зобов'язаний** або обробити його за допомогою `try-catch`, або оголосити, що він його "прокидає" далі за допомогою ключового слова `throws`.
  * Зазвичай представляють помилки, що залежать від зовнішніх умов.
  * **Приклади:** `IOException`, `SQLException`, `FileNotFoundException`.

#### Unchecked Exceptions (Неперевірювані винятки)

  * Це винятки, які **не перевіряються компілятором**. Їх не обов'язково обробляти чи оголошувати.
  * До них належать всі нащадки `RuntimeException`.
  * Зазвичай представляють логічні помилки в програмі, яких можна було уникнути.
  * **Приклади:** `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException`.

-----

## Як працює механізм винятків: Стек викликів

Коли програма виконується, JVM веде облік послідовності викликів методів у структурі даних, що називається **стеком викликів (Method Call Stack)**. Це структура типу LIFO (Last-In, First-Out).

![Стек викликів](attachments/04_call_stack.png)

Коли в методі виникає виняток, відбувається наступне:

1.  Створюється об'єкт винятку.
2.  JVM **припиняє** нормальне виконання і починає шукати обробник цього винятку.
3.  Пошук починається в поточному методі. Якщо відповідний `catch`-блок не знайдено, метод **негайно завершується**, і JVM "розкручує" стек, переходячи до методу, який його викликав.
4.  Цей процес повторюється для кожного методу в стеку, поки не буде знайдено обробник.
5.  Якщо обробник так і не знайдено аж до методу `main()`, програма **аварійно завершується**, а JVM викликає обробник за замовчуванням, який друкує **стек-трейс (stack trace)** помилки.

![Взаємодія винятку та стеку викликів](attachments/04_exception_call_stack.png)

-----

## Обробка винятків: `try`, `catch`, `finally`

Для керування винятками в Java використовуються п'ять ключових слів: `try`, `catch`, `finally`, `throw`, `throws`.

#### Синтаксис `try-catch-finally`

```java
try {
    // Код, який може кинути виняток
} catch (ТипВинятку1 ex1) {
    // Блок для обробки винятку типу ТипВинятку1
} catch (ТипВинятку2 ex2) {
    // Блок для обробки винятку типу ТипВинятку2
} finally {
    // Код, який виконається ЗАВЖДИ,
    // незалежно від того, був виняток чи ні
}
```

  * **`try`**: Блок, у який поміщається потенційно небезпечний код.
  * **`catch`**: Блок-обробник. Він "ловить" об'єкт винятку певного типу. Можна мати кілька `catch`-блоків для різних типів винятків.
  * **`finally`**: Необов'язковий блок, код якого **гарантовано виконається** після завершення блоку `try` (і `catch`, якщо він був викликаний). Зазвичай використовується для звільнення ресурсів (закриття файлів, з'єднань з базою даних).

![Обробка винятків](attachments/04_exception_handling.png)

-----

## Найкращі практики та User-Defined Exceptions

#### Переваги правильної обробки винятків

  * **Завершення роботи програми:** Дозволяє програмі коректно завершити роботу, навіть якщо сталася помилка.
  * **Відокремлення коду:** Чітко розділяє основну логіку від коду обробки помилок.
  * **Поширення помилок:** Дозволяє передавати інформацію про помилку вгору по стеку викликів.
  * **Осміслені звіти про помилки:** Надає детальну інформацію для діагностики.

#### Власні винятки (User-Defined Exceptions)

Іноді стандартних винятків недостатньо для моделювання специфічних помилок вашого додатку. У таких випадках ви можете створювати власні класи винятків, наслідуючись від `Exception` (для checked) або `RuntimeException` (для unchecked). Це робить код більш читабельним та специфічним для вашої бізнес-логіки.

-----

## Assertions (Твердження)

**Assertion** — це інструмент для відладки, що дозволяє перевіряти припущення у вашому коді.

  * **Синтаксис:** `assert умова;` або `assert умова : "повідомлення";`
  * **Принцип роботи:** Якщо умова є `false`, кидається виняток `AssertionError`.
  * **Важливо:** За замовчуванням твердження вимкнені. Щоб їх увімкнути, JVM потрібно запускати з прапором `-ea` (enable assertions). Вони не повинні використовуватися для перевірки даних, що надходять від користувача, а лише для перевірки внутрішніх інваріантів програми.

### Приклад використання Assertions

Розглянемо простий приклад: метод, який обчислює якусь величину (наприклад, вартість зі знижкою), і ми хочемо бути впевнені, що вхідне значення (ціна) завжди є додатним. Ми припускаємо, що перевірка на від'ємні значення вже відбулася десь раніше (наприклад, на етапі вводу даних), і `assert` тут слугує як додаткова "запобіжна сітка" для виявлення логічних помилок розробника.

```java
// AssertExample.java
public class AssertExample {

    /**
     * Метод для обчислення знижки.
     * Він припускає, що ціна завжди буде додатним числом.
     */
    public static double calculateDiscount(double price) {
        // Перевіряємо внутрішню умову (інваріант).
        // Ми, як розробники, припускаємо, що цей метод НІКОЛИ не буде викликаний
        // з від'ємною ціною. Assertion - це спосіб перевірити це припущення під час розробки.
        assert (price >= 0) : "Помилка в логіці: ціна не може бути від'ємною. Price = " + price;

        // Якщо умова виконана, продовжуємо роботу
        double discount = price * 0.1; // 10% знижка
        return price - discount;
    }

    public static void main(String[] args) {
        // 1. Коректний виклик
        System.out.println("Виклик з ціною 100.0...");
        double result1 = calculateDiscount(100.0);
        System.out.println("Ціна зі знижкою: " + result1);

        System.out.println("\n----------------\n");

        // 2. Некоректний виклик, який спричинить AssertionError
        System.out.println("Виклик з ціною -50.0...");
        double result2 = calculateDiscount(-50.0);
        System.out.println("Ціна зі знижкою: " + result2);
    }
}
```

-----

### Як це скомпілювати та запустити

1.  **Компіляція (як зазвичай):**

    ```bash
    javac AssertExample.java
    ```

2.  **Запуск БЕЗ увімкнених тверджень:**
    Якщо запустити програму звичайною командою, твердження будуть проігноровані.

    ```bash
    java AssertExample
    ```

    **Результат:**

    ```
    Виклик з ціною 100.0...
    Ціна зі знижкою: 90.0

    ----------------

    Виклик з ціною -50.0...
    Ціна зі знижкою: -45.0
    ```

    Як бачимо, програма відпрацювала без помилок, але повернула логічно некоректний результат.

3.  **Запуск З увімкненими твердженнями:**
    Щоб увімкнути перевірку, використовуйте прапор **`-ea`** (enable assertions).

    ```bash
    java -ea AssertExample
    ```

    **Результат:**

    ```
    Виклик з ціною 100.0...
    Ціна зі знижкою: 90.0

    ----------------

    Виклик з ціною -50.0...
    Exception in thread "main" java.lang.AssertionError: Помилка в логіці: ціна не може бути від'ємною. Price = -50.0
        at AssertExample.calculateDiscount(AssertExample.java:9)
        at AssertExample.main(AssertExample.java:27)
    ```

    Тепер програма аварійно завершилася, кинувши `AssertionError`, і точно вказала на місце логічної помилки, яку можна виправити на етапі розробки.

-----

## ✅ Контрольні питання

1.  **Концепція.** У чому полягає ключова різниця між `Error` та `Exception` в Java? Наведіть по одному прикладу для кожного.
2.  **Класифікація.** Що таке `Checked` та `Unchecked` exceptions? Наведіть по одному прикладу. Чому компілятор змушує обробляти одні, але не змушує обробляти інші?
3.  **Механізм.** Опишіть, що відбувається, коли в методі виникає виняток, і жоден `catch`-блок у стеку викликів не може його обробити.
4.  **Застосування.** Для чого використовується блок `finally`? Напишіть короткий приклад коду, де використання `finally` є доцільним.

<details markdown="1">
<summary>Відповіді (спробуйте спочатку відповісти самі)</summary>

1.  **`Error`:** Це критична, невідновлювана помилка, що сталася в самій JVM, і яку програма не повинна намагатися обробити. **Приклад:** `OutOfMemoryError` або `StackOverflowError`.
    **`Exception`:** Це помилка, що сталася в логіці програми, яку можна (і часто потрібно) передбачити та обробити. **Приклад:** `IOException` або `NullPointerException`.

2.  **`Checked` (Перевірювані):** Це винятки, які компілятор *змушує* вас обробляти (через `try-catch`) або оголошувати (через `throws`). Вони зазвичай пов'язані з зовнішніми факторами, які ви не можете контролювати (напр., файл не знайдено - `FileNotFoundException`). Компілятор змушує їх обробляти, бо це *очікувана* помилкова ситуація.
    **`Unchecked` (Неперевірювані, `RuntimeException`):** Це винятки, які компілятор *не* змушує обробляти. Вони зазвичай є наслідком логічних помилок у коді (напр., `NullPointerException`, `ArrayIndexOutOfBoundsException`). Компілятор не змушує їх обробляти, бо вважається, що програміст повинен *виправити код*, а не ловити ці помилки.

3.  Якщо жоден метод у стеку викликів не має відповідного `catch`-блоку, виняток "доходить" до методу `main()`. Якщо і там його не оброблено, програма **аварійно завершується**, і обробник за замовчуванням виводить у консоль повний **стек-трейс (stack trace)** помилки.

4.  Блок `finally` використовується для коду, який має **гарантовано виконатися** незалежно від того, чи стався виняток у блоці `try`, чи ні. Це критично важливо для звільнення ресурсів, щоб уникнути їх "витоку".

    ```java
    Connection dbConnection = null;
    try {
        dbConnection = DriverManager.getConnection("url");
        // ... якась робота з базою ...
    } catch (SQLException e) {
        // обробка помилки
    } finally {
        if (dbConnection != null) {
            try {
                dbConnection.close(); // Гарантовано закриваємо з'єднання
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    ```

    (Хоча в сучасній Java (7+) для цього краще використовувати `try-with-resources`).

</details>