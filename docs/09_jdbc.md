# Лекція 9: JDBC. Як Java спілкується з базами даних

## ⚡ Експрес-опитування: Активація знань

На попередніх лекціях ми багато говорили про помилки та стабільність:

1.  У [Лекції 7](07_troubleshooting.md) ми бачили приклад `PSQLException`. Що, на вашу думку, означає "PSQL" і до чого тут "Exception"?
2.  У [Лекції 4](04_java_exceptions.md) ми обговорювали `Checked` та `Unchecked` винятки. Як ви думаєте, `SQLException` (помилка бази даних) — це `Checked` чи `Unchecked`? Чому?
3.  У [Лекції 5 (SOLID)](05_solid.md) ми вивчали Принцип Інверсії Залежностей (DIP). Як він може бути корисним при роботі з різними базами даних (напр., MySQL та PostgreSQL)?

<details markdown="1">
<summary>Наші очікування (відповідь)</summary>

1.  "PSQL" — це скорочення від **PostgreSQL**, популярної системи управління базами даних. `PSQLException` — це специфічний виняток, який виникає при помилці роботи з цією БД.
2.  `SQLException` — це **Checked Exception**. Чому? Тому що проблеми зі зв'язком, неправильні запити або недоступність БД — це *очікувані* проблеми у зовнішній системі, які програміст *зобов'язаний* обробити (на відміну від `NullPointerException`, який є логічною помилкою програміста).
3.  Завдяки DIP, наш високорівневий код (напр., `OrderService`) не повинен залежати від `MySqlRepository`. Він має залежати від інтерфейсу `OrderRepository`. Це дозволить нам легко "підмінити" реалізацію `MySqlRepository` на `PostgresRepository`, не змінюючи бізнес-логіку.

</details>

## Вступ: Що таке База Даних?

Привіт усім\! Сьогодні ми говоримо про те, як наші Java-додатки взаємодіють зі світом даних.

**База даних (БД)** — це не просто Excel-табличка. Це організована колекція структурованої інформації, що зберігається в комп'ютерній системі. Зазвичай нею керує спеціальна програма — **система управління базами даних (СУБД)**. Дані, СУБД та додатки, що з ними працюють, разом називають системою баз даних.

У найпоширеніших типах БД дані моделюються у вигляді рядків та стовпців у серії таблиць. Це робить обробку та запити даних ефективними. Більшість баз даних використовують **Structured Query Language (SQL)** для запису та отримання даних.

Зверніть увагу, що коли ми говоримо про логування помилок (як у [Лекції 8](08_logging.md)), бази даних часто є джерелом цих помилок (наприклад, `PSQLException` у [Лекції 7](07_troubleshooting.md)).

-----

## Бази Даних vs. Таблиці (Excel)

І БД, і електронні таблиці (як-от Excel) зручні для зберігання інформації. Але між ними є ключові відмінності:

  * **Як зберігаються та обробляються дані**
  * **Хто може отримати доступ до даних**
  * **Скільки даних можна зберігати**

Таблиці Excel чудово підходять для одного користувача або невеликої групи, яким не потрібна складна маніпуляція даними.

Бази даних, з іншого боку, призначені для зберігання величезних обсягів організованої інформації. Вони дозволяють **багатьом користувачам одночасно** та безпечно отримувати доступ до даних, використовуючи дуже складну логіку та мови запитів.

-----

## Типи Баз Даних: SQL та NoSQL

Світ баз даних величезний, але його можна поділити на великі родини.

  * **Relational (SQL) Databases:**

      * **Приклади:** MySQL, Oracle, PostgreSQL, MS SQL Server.
      * **Ключові риси:** Зв'язки та цілісність даних (Relationship & referential integrity), структуровані дані, підтримка SQL, **ACID-транзакції**, індексація.
      * Вони поділяються на **OLTP** (обробка транзакцій, як-от замовлення в магазині) та **OLAP** (аналітика, як-от річні звіти).

  * **NoSQL Databases:**
    Це ціла група нереляційних баз даних, кожна зі своєю спеціалізацією.

      * **Document-based (Документні):** Зберігають дані в гнучких форматах, як-от JSON.
          * *Приклади:* **MongoDB**, Couchbase.
      * **Key-Value (Ключ-Значення):** Найпростіший тип, як гігантський `Map`.
          * *Приклади:* **Redis**, DynamoDB.
      * **Column-based (Колонкові):** Оптимізовані для швидкого читання великих обсягів даних в певних колонках.
          * *Приклади:* **Cassandra**, HBase.
      * **Graph-based (Графові):** Створені для зберігання зв'язків (наприклад, соціальні мережі).
          * *Приклади:* **Neo4j**, Neptune.

  * **Time-series Databases (Часові ряди):**

      * **Приклади:** InfluxDB, Prometheus.
      * **Ключові риси:** Оптимізовані для надшвидкого запису та запитів даних, прив'язаних до часу (моніторинг, IoT).

-----

## Теорема CAP: Чим доводиться жертвувати

Ви не можете мати все одночасно. **Терема CAP** — це фундаментальний принцип розподілених систем, який стверджує, що будь-яка база даних може гарантувати лише **дві з трьох** властивостей:

  * **C (Consistency / Узгодженість):** Усі клієнти бачать однакові дані в один і той самий час.
  * **A (Availability / Доступність):** Кожен запит отримує відповідь (навіть якщо дані не найсвіжіші).
  * **P (Partition Tolerance / Стійкість до розділення):** Система продовжує працювати, навіть якщо зв'язок між її вузлами (серверами) розірвався.

Це призводить до трьох компромісів:

  * **CA (Узгодженість + Доступність):** Традиційні реляційні СУБД (RDBMS). Вони не дуже добре переносять розділення.
  * **CP (Узгодженість + Стійкість):** Системи, які жертвують доступністю, щоб гарантувати, що дані завжди правильні.
      * *Приклади:* MongoDB, Redis, HBase.
  * **AP (Доступність + Стійкість):** Системи, які завжди дадуть вам відповідь, навіть якщо дані "застаріли" на кілька секунд.
      * *Приклади:* Cassandra, CouchDB, DynamoDB.

-----

## Що таке JDBC?

Нарешті, як Java з усім цим працює?

**JDBC (Java Database Connectivity)** — це стандартний Java API, який дозволяє підключатися та виконувати запити до бази даних. Це специфікація, яка надає стандартну **абстракцію** для Java-додатків для зв'язку з різними БД.

JDBC, разом із драйвером бази даних, дозволяє отримувати доступ до реляційних баз даних і навіть електронних таблиць.

### Ключові компоненти JDBC

1.  **JDBC API:** Надає основні методи та інтерфейси (`Connection`, `Statement` тощо) для легкого спілкування з БД.
2.  **JDBC Driver Manager:** Завантажує специфічний для бази даних **драйвер** у додаток, щоб встановити з'єднання.
3.  **JDBC Test Suite:** Використовується для тестування операцій (CRUD) у драйверах.
4.  **JDBC-ODBC Bridge:** (Зараз історичний) Дозволяв Java-драйверам "спілкуватися" зі старими ODBC-драйверами.

-----

## 4 Типи Драйверів JDBC

Драйвери JDBC — це адаптери на стороні клієнта, які перетворюють запити з Java-програми на протокол, зрозумілий для СУБД. Їх є 4 типи, але вам потрібно знати лише про один:

  * **Type-1 (JDBC-ODBC bridge):** Старий і повільний.
  * **Type-2 (Native-API):** Вимагає встановлення "нативних" бібліотек клієнта БД.
  * **Type-3 (Network Protocol):** Використовує проміжне ПЗ (middleware).
  * **Type-4 (Thin Driver):** **Це сучасний стандарт.** Це 100% Java-драйвер, який спілкується з базою даних напряму через її мережевий протокол. Йому не потрібно нічого, крім JAR-файлу в вашому проєкті.

-----

## Ключові Інтерфейси JDBC API

Ви не будете використовувати їх усі, але важливо знати головних "дійових осіб":

  * `Driver`: Сам драйвер (наприклад, від PostgreSQL).
  * `Connection`: Ваше активне з'єднання з базою даних. Це найцінніший ресурс.
  * `Statement`: Об'єкт, що використовується для виконання простих SQL-запитів. **Небезпечний**, оскільки вразливий до SQL-ін'єкцій.
  * `PreparedStatement`: **Ви повинні використовувати саме його.** Це попередньо скомпільований SQL-запит з "плейсхолдерами" (`?`). Він запобігає SQL-ін'єкціям, оскільки дані та сама команда запиту надсилаються до БД окремо.
  * `CallableStatement`: Використовується для виклику збережених процедур у БД.
  * `ResultSet`: Таблиця даних, що повертається з БД (результат запиту `SELECT`).
  * `ResultSetMetaData` / `DatabaseMetaData`: Надають інформацію *про саму БД* або *про результати* (назви колонок, типи тощо).

-----

## Життєвий цикл JDBC-запиту

Робота з JDBC — це чіткий 5-кроковий процес.

**0. Завантажити драйвер**
У сучасній Java це відбувається автоматично, але раніше потрібно було викликати `Class.forName()`.

**1. Отримати з'єднання (`Connection`)**
Використовуючи `DriverManager`, ви "просите" з'єднання, передаючи URL бази даних, логін та пароль.

**2. Створити вираз (`Statement` або `PreparedStatement`)**
Ви отримуєте об'єкт "запиту" з вашого з'єднання.

**3. Виконати запит**

  * **`executeQuery()`:** Для `SELECT`. Повертає `ResultSet` (таблицю з даними).
  * **`executeUpdate()`:** Для `INSERT`, `UPDATE`, `DELETE`. Повертає `int` (кількість змінених рядків).

**4. Обробити результат (`ResultSet`)**
Якщо ви робили `SELECT`, ви "пробігаєте" по `ResultSet` у циклі `while (resultSet.next()) { ... }` і дістаєте дані з колонок (`resultSet.getString("name")`, `resultSet.getInt("age")` тощо).

**5. Закрити ресурси (Найважливіший крок\!)**
Ви *зобов'язані* закрити `ResultSet`, `Statement` та `Connection` у зворотному порядку, щоб звільнити ресурси.

**Сучасна практика:** Використовуйте `try-with-resources` (з Java 7), щоб це відбувалося автоматично.

-----

## JDBC: Резюме

JDBC — це **низькорівневий API**, який дозволяє Java-додаткам взаємодіяти з базами даних.

  * Ви пишете **"сирі" SQL-запити** вручну.
  * Ви **вручну обробляєте `ResultSet`**, щоб отримати дані.
  * Ви **явно керуєте** з'єднаннями та транзакціями.

-----

## Погляд у майбутнє: JPA (Java Persistence API)

Писати "сирий" JDBC — це довго і складно. Тому в сучасних ентерпрайз-додатках використовують **JPA (Java Persistence API)**.

JPA — це **високорівневий API** для управління реляційними даними. Це специфікація для **ORM (Object-Relational Mapping)**.

  * **Що це означає?** Ви перестаєте думати в термінах SQL-таблиць і починаєте думати в термінах Java-об'єктів.
  * **Менше SQL:** Ви не пишете `SELECT * FROM users...`. Ви пишете `userRepository.findById(1)`. JPA сама генерує SQL-запит за вас.
  * **Управління сутностями:** JPA керує життєвим циклом ваших об'єктів (створення, читання, оновлення, видалення).

### Зв'язок JPA та JDBC

**JPA — це абстракція, побудована поверх JDBC.** Коли ви викликаєте `userRepository.save(user)`, JPA "під капотом" генерує SQL-запит `INSERT INTO...`, відкриває `Connection` через JDBC, створює `PreparedStatement` і виконує його.

JPA просто звільняє вас від написання 90% шаблонного JDBC-коду, дозволяючи зосередитись на бізнес-логіці.

-----

## ✅ Контрольні питання

1.  **Концепція:** У чому полягають 3 основні відмінності між базою даних та електронною таблицею (Excel)?
2.  **Типи:** Назвіть 4 основні типи NoSQL баз даних та по одному прикладу для кожної.
3.  **Теорія:** Що таке Теорема CAP? Які два компроміси найчастіше обирають NoSQL-системи?
4.  **JDBC:** Що таке JDBC і яка роль драйвера Type-4?
5.  **Безпека:** Чому `PreparedStatement` є безпечнішим, ніж `Statement`?
6.  **API:** Який метод JDBC викличе `SELECT`, а який — `UPDATE`? Що вони повертають?
7.  **Життєвий цикл:** Назвіть 5 основних кроків життєвого циклу JDBC-запиту.
8.  **JPA:** Що таке JPA (ORM) і як він пов'язаний з JDBC?

<details markdown="1">
<summary>Відповіді (спробуйте спочатку відповісти самі)</summary>

1.  **БД vs Excel:**

    1.  **Обробка даних:** БД використовують складну логіку та SQL для маніпуляцій, Excel — прості формули.
    2.  **Доступ:** БД розраховані на одночасний доступ багатьох користувачів, Excel — переважно на одного.
    3.  **Обсяг:** БД призначені для зберігання величезних обсягів даних, Excel — для значно менших.

2.  **Типи NoSQL:**

    1.  **Документні (Document-based):** MongoDB
    2.  **Ключ-Значення (Key-Value):** Redis
    3.  **Колонкові (Column-based):** Cassandra
    4.  **Графові (Graph-based):** Neo4j

3.  **Теорема CAP:** Це принцип, що розподілена система може одночасно гарантувати лише дві з трьох властивостей: **C**onsistency (Узгодженість), **A**vailability (Доступність) або **P**artition Tolerance (Стійкість до розділення).

      * Оскільки стійкість до розділення (P) є обов'язковою для будь-якої розподіленої системи, NoSQL-бази найчастіше обирають компроміс між:
        1.  **CP (Узгодженість + Стійкість):** Жертвують доступністю (напр., MongoDB, Redis).
        2.  **AP (Доступність + Стійкість):** Жертвують узгодженістю (напр., Cassandra, DynamoDB).

4.  **JDBC:** Це стандартний Java API (абстракція) для підключення та виконання запитів до баз даних. **Драйвер Type-4 (Thin Driver)** — це 100% Java-драйвер, який напряму спілкується з БД через її мережевий протокол. Це сучасний стандарт, який не потребує нічого, крім `.jar` файлу.

5.  **Безпека:** `PreparedStatement` є безпечнішим, оскільки він запобігає **SQL-ін'єкціям**. Він компілює SQL-запит з плейсхолдерами (`?`) окремо, а дані передає іншим каналом. Таким чином, дані, введені користувачем (напр., `'; DROP TABLE users; --`), ніколи не стануть частиною виконуваної SQL-команди. `Statement` просто вставляє дані в рядок, що дозволяє ін'єкцію.

6.  **API:**

      * `SELECT` виконується методом **`executeQuery()`**, який повертає об'єкт `ResultSet` (таблицю з даними).
      * `UPDATE` (а також `INSERT` та `DELETE`) виконується методом **`executeUpdate()`**, який повертає `int` (кількість змінених рядків).

7.  **Життєвий цикл JDBC:**

    1.  Отримати з'єднання (`Connection`).
    2.  Створити вираз (`Statement` / `PreparedStatement`).
    3.  Виконати запит (`executeQuery` / `executeUpdate`).
    4.  Обробити результат (`ResultSet` або `int`).
    5.  Закрити ресурси (`ResultSet`, `Statement`, `Connection`).

8.  **JPA (ORM):** JPA — це **високорівнева абстракція** (специфікація ORM), яка дозволяє працювати з БД через Java-об'єкти, а не "сирі" SQL-запити. **Він побудований поверх JDBC**. JPA генерує SQL-запити за вас і використовує JDBC "під капотом" для їх виконання, звільняючи розробника від шаблонного коду.

</details>