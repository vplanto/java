# Лекція 8: "Чорна скринька" вашого додатку. Вступ до логування

## ⚡ Експрес-опитування: Активація знань

На [попередній лекції](07_troubleshooting.md) ми говорили про пошук помилок. Давайте пригадаємо:

1.  Який наш найперший інструмент для "моделювання в голові", коли програма "падає"?
2.  Чим поганий `System.out.println` для діагностики у великому додатку?
3.  Ми бачили приклад `Stack Trace`. Що корисного, окрім самого винятку, він нам показував?

<details markdown="1">
<summary>Наші очікування (відповідь)</summary>

1.  **Аналіз Stack Trace.** Це "звіт", який показує, що саме і де саме зламалося.
2.  `System.out.println` "засмічує" консоль, ми не можемо ним керувати (вимкнути для продакшену), і він не дає жодного контексту (час, потік, рівень важливості).
3.  Він показував **послідовність викликів** (які методи викликали які) та **номери рядків**, що дозволяє точно відстежити шлях помилки.

</details>

Сьогодні ми поговоримо про `System.out.println` на стероїдах — професійний інструмент, який вирішує всі ці проблеми.

## Вступ: Жорстока правда життя

Привіт усім\! Якби ми жили у світі, де програми ніколи не дають збоїв, цієї лекції б не існувало. Але ми живемо в реальному світі, де:

  * Додаток "зависає" без видимої причини.
  * Система раптово починає відповідати на запити по 10 секунд, хоча годину тому все "літало".
  * Помилка, що сталася *зараз*, була спричинена подіями, які відбулися *годину тому*.

У всіх цих випадках нам відчайдушно потрібна інформація про те, що відбувалося всередині системи. Цей процес запису "бортового журналу" називається **логуванням**.

(Ця лекція є глибоким зануренням у тему, яку ми анонсували у [Лекції 7: Пошук та усунення несправностей](07_troubleshooting.md)).

### Головний конфлікт логування

Існує фундаментальне протиріччя:

  * **Розробник (під час "пожежі")** хоче *максимум* інформації. Йому потрібен кожен крок.
  * **Користувач (і система)** хочуть *мінімум* логування. Будь-який запис у лог — це витрати часу CPU та дискових операцій. (Були випадки, коли надмірне логування сповільнювало систему в 50 разів\!)

Сучасні системи логування вирішують цей конфлікт, дозволяючи нам гнучко керувати рівнем деталізації, в ідеалі — прямо під час роботи додатку.

-----

## "Зоопарк" фреймворків: Як ми дійшли до SLF4J

Колись у Java-світі панував хаос. Існувало (і досі існує) багато систем логування:

  * **Log4j (v1):** Старий король, колись дуже популярний і добре продуманий.
  * **`java.util.logging` (JUL):** Вбудований у Java, але менш гнучкий і не такий інтуїтивний, як Log4j.
  * **Apache Commons Logging (JCL):** Перша спроба створити "адаптер" (фасад), щоб бібліотеки не залежали від конкретної реалізації.
  * **Logback:** Створений тим самим автором, що й Log4j, як його прямий наступник.

### Проблема: Залежність бібліотек

Уявіть, що ви пишете бібліотеку. На який фреймворк вам орієнтуватися? Якщо ви оберете Log4j, а користувач вашої бібліотеки використовує JUL, виникне конфлікт.

### Рішення: Фасад (Facade)

Для вирішення цієї проблеми були створені **фасади**. Фасад — це просто набір інтерфейсів (API), до якого "говорить" ваш код. А вже під час запуску до цього фасаду підключається реальний "двигун" логування.

Сьогодні промисловим стандартом є **SLF4J (Simple Logging Facade for Java)**.

**Сучасний стек логування виглядає так:**

1.  **Фасад (API): `SLF4J`** — Ваш код залежить *тільки* від нього.
2.  **Реалізація (Двигун): `Logback`** — Найпоширеніша "нативна" реалізація SLF4J, яка виконує всю важку роботу. (Альтернатива — Log4j2).

Ваш код: `MyClass.java` -> `SLF4J API` -> `Logback (двигун)` -> `File / Console`

-----

## Три кити логування

Будь-яка потужна система логування (Log4j, Logback) стоїть на трьох основних поняттях:

1.  **Logger (Логер):** *Що* і *де* логувати?
2.  **Appender (Апендер):** *Куди* логувати?
3.  **Layout (Шаблон/Компоновка):** *Як* (в якому форматі) логувати?

### 1\. Logger (Логер)

Логер — це об'єкт, який ви використовуєте у своєму коді для надсилання повідомлень.

#### Ієрархія

Логери організовані в ієрархію, подібно до пакетів Java, використовуючи крапку як роздільник.

  * Логер `com.mycompany` є батьком для `com.mycompany.service`.
  * Існує головний, **кореневий (root) логер**, який є батьком для всіх.

**Найкраща практика:** Отримувати логер за іменем класу, в якому він використовується.

```java
// У класі com.mycompany.service.UserService
private static final Logger logger = LoggerFactory.getLogger(UserService.class);
```

Таким чином, ім'я логера автоматично стає `com.mycompany.service.UserService`.

#### Рівні логування

Це інструмент, який вирішує наш "головний конфлікт". Ви пишете повідомлення з певним рівнем важливості:

  * `logger.trace("Дуже детальна інформація для відладки");`
  * `logger.debug("Відлагоджувальна інформація");`
  * `logger.info("Щось сталося (наприклад, 'Сервер стартував')");`
  * `logger.warn("Щось пішло не так, але не критично");`
  * `logger.error("Сталася серйозна помилка");`

#### Фільтрація та успадкування рівнів

Кожен логер має "ефективний рівень". Якщо ви встановите логеру `com.mycompany` рівень `INFO`, то:

  * Усі повідомлення `TRACE` та `DEBUG` для цього логера (та його нащадків) будуть **проігноровані**.
  * Усі повідомлення `INFO`, `WARN`, `ERROR` будуть **опубліковані**.

Якщо логеру рівень не вказано, він **успадковує** його від найближчого батька.

**Приклад:**
Ви можете встановити `root` рівень `WARN` (для продакшену), але для проблемного модуля `com.mycompany.payment` тимчасово увімкнути `DEBUG`, не чіпаючи решту системи.

### 2\. Appender (Апендер)

Апендер — це кінцевий пункт призначення вашого лог-повідомлення.
Найпоширеніші типи:

  * `ConsoleAppender`: Виводить у консоль (System.out/err).
  * `FileAppender`: Пише у файл.
  * Інші: `DBAppender` (пише в базу даних), `SocketAppender` (надсилає по мережі), `SMTPAppender` (надсилає email при `ERROR`).

#### Log Rotation (Ротація логів)

Використовувати простий `FileAppender` небезпечно — він буде рости до нескінченності. На практиці завжди використовують ротацію:

  * **`RollingFileAppender`:** Ротація за розміром. Коли лог досягає, наприклад, 100MB, він перейменовується в `app.0.log`, а новий `app.log` створюється з нуля.
  * **`DailyRollingFileAppender`:** Ротація за часом (наприклад, щодня). Лог за вчора архівується (напр., `app.2025-11-04.log`).

(Сучасний Logback об'єднує їх в один потужний `RollingFileAppender`).

#### Additivity (Адитивність)

За замовчуванням, логер надсилає повідомлення *своєму* апендеру І *всім апендерам своїх батьків*.

  * **Приклад:** Якщо `root` пише в `Console`, а `com.mycompany` пише у `File`, то повідомлення для `com.mycompany` потрапить **і у файл, і в консоль**.
  * Іноді це не те, що вам потрібно. Це можна вимкнути, встановивши логеру `additivity="false"`.

### 3\. Layout (Шаблон/Компоновка)

Layout відповідає за форматування повідомлення. На практиці 99% часу використовується **`PatternLayout`** — шаблон, який ви налаштовуєте самі.

**Приклад поганого, нечитабельного логу:**

```
INFO
Some message
ERROR
Another message
DEBUG
...
```

**Приклад гарного, читабельного логу:**

```
2025-11-04 22:30:15,123 [main] INFO  com.my.App - Сервер стартував
2025-11-04 22:30:16,456 [Thread-1] DEBUG com.my.UserService - Знайдено користувача id=123
2025-11-04 22:30:16,457 [Thread-1] ERROR com.my.PaymentService - Помилка платежу!
```

Ця краса досягається завдяки **вирівнюванню** (`%-5p`, `%-16t`, `%.32c`), яке робить лог чистим, як таблиця.

**Розшифровка типового шаблону:**

  * `%d{ISO8601}` - Дата і час у форматі ISO.
  * `[%t]` або `[%-16.16t]` - Ім'я потоку (вирівняне до 16 символів).
  * `%-5p` - Рівень логування (INFO, DEBUG), вирівняний вліво на 5 символів.
  * `%c{32}` або `[%32.32c]` - Ім'я логера (категорія), скорочене до 32 символів.
  * `%m` - Ваше повідомлення.
  * `%n` - Новий рядок.

-----

## Найкращі практики та "Killer-feature": MDC

### 1\. `if (logger.isDebugEnabled())`

Коли ви пишете код з конкатенацією:
`logger.debug("Дані: " + user.getName() + " та " + order.getId());`

Цей рядок **завжди буде створено**, навіть якщо у вас в налаштуваннях стоїть рівень `INFO`. Ви даремно витрачаєте ресурси. Раніше це вирішували так:

```java
if (logger.isDebugEnabled()) {
    logger.debug("Дані: " + user.getName() + " та " + order.getId());
}
```

### 2\. (Сучасне рішення) Плейсхолдери SLF4J

SLF4J вирішує цю проблему елегантно:
`logger.debug("Дані: {} та {}", user.getName(), order.getId());`

SLF4J достатньо розумний, щоб *спочатку* перевірити, чи увімкнено `DEBUG`, і *тільки потім* форматувати рядок. Це швидко і чисто.

### 3\. MDC (Mapped Diagnostic Context)

Це найпотужніший інструмент для відладки.

**Проблема:** У вас веб-сервер. Тисячі користувачів одночасно. Один з них (наприклад, `user-123`) скаржиться на помилку. Як знайти *саме його* дії у лог-файлі, де все перемішано?

**Рішення:** MDC — це "мапа" (`Map<String, String>`), прив'язана до *поточного потоку*.

1.  **На початку запиту** (наприклад, у фільтрі сервлета) ви додаєте контекст:
    `MDC.put("userId", "user-123");`
2.  Ви додаєте `[%X{userId}]` до свого шаблону `PatternLayout`.
3.  **Результат:** *Кожне* лог-повідомлення, згенероване *цим потоком* (навіть з бібліотек\!), автоматично отримає префікс `[user-123]`.
    `... [Thread-1] [user-123] ERROR com.my.PaymentService - Помилка платежу!`
4.  **В кінці запиту** (у блоці `finally`) ви *обов'язково* чистите контекст:
    `MDC.remove("userId");`

Це дозволяє вам миттєво відфільтрувати весь життєвий цикл одного запиту серед мільйонів інших.

-----

## Конфігурація: Приклад (Сучасний `logback.xml`)

Ось як виглядає конфігурація `logback.xml`, яка об'єднує всі ці ідеї:

```xml
<configuration>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} [%X{userId}] - %msg%n</pattern>
    </encoder>
  </appender>

  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/my-app.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>logs/my-app.%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
    <encoder>
      <pattern>%d{ISO8601} [%thread] %-5level %logger{36} [%X{userId}] - %msg%n</pattern>
    </encoder>
  </appender>

  <logger name="com.mycompany" level="DEBUG" additivity="false">
    <appender-ref ref="STDOUT" />
    <appender-ref ref="FILE" />
  </logger>

  <logger name="org.hibernate" level="WARN" />

  <root level="INFO">
    <appender-ref ref="STDOUT" />
  </root>

</configuration>
```

-----

## ✅ Контрольні питання

1.  **Конфлікт:** Поясніть "головний конфлікт" логування. Як рівні (Levels) допомагають його вирішити?
2.  **Стек:** Назвіть 2 компоненти сучасного стеку логування. Який є "фасадом" (API), а який "двигуном" (реалізацією)?
3.  **Компоненти:** У чому різниця між Логером, Апендером та Шаблоном?
4.  **Ієрархія:** У вас є логер `com.app.service` з рівнем `DEBUG`. Його батько, `com.app`, має рівень `INFO`. Який "ефективний рівень" буде у логера `com.app.service`?
5.  **Additivity:** Якщо `root` логер пише в `Console`, а логер `com.app` пише у `File` (і additivity=true), куди потрапить повідомлення від `com.app`?
6.  **Практика:** Чому `logger.debug("User: " + user.getName());` гірше, ніж `logger.debug("User: {}", user.getName());`?
7.  **MDC:** Поясніть, яку проблему вирішує MDC (Mapped Diagnostic Context) і як він працює (на прикладі `userId`).

<details markdown="1">
<summary>Відповіді (спробуйте спочатку відповісти самі)</summary>

1.  **Конфлікт:** Розробник під час відладки хоче *максимум* інформації, але система на продакшені хоче *мінімум* логування, оскільки це витрачає ресурси CPU та диска. **Рівні логування** (TRACE, DEBUG, INFO, WARN, ERROR) вирішують це, дозволяючи динамічно (через конфігурацію) вмикати детальні повідомлення (`DEBUG`) на тестовому стенді та вимикати їх (`INFO` або `WARN`) на продакшені, не змінюючи код.

2.  **Стек:** Сучасний стек — це **`SLF4J`** (фасад/API, від якого залежить код) та **`Logback`** (двигун/реалізація, який виконує роботу).

3.  **Компоненти:**

      * **Logger (Логер):** Об'єкт у коді, який приймає повідомлення та вирішує, чи достатньо воно важливе (на основі рівня) для відправки далі.
      * **Appender (Апендер):** Кінцевий пункт призначення повідомлення (напр., `ConsoleAppender` - консоль, `FileAppender` - файл).
      * **Layout (Шаблон):** Правило форматування, яке перетворює об'єкт повідомлення на читабельний рядок (напр., додає час, рівень, ім'я потоку).

4.  **Ієрархія:** Ефективний рівень буде **`DEBUG`**. Рівні логування успадковуються, але якщо рівень *явно* встановлений для дочірнього логера (`com.app.service`), він має вищий пріоритет, ніж рівень батька (`com.app`).

5.  **Additivity:** Повідомлення потрапить **в обидва місця**: і у `File` (через власний апендер `com.app`), і в `Console` (оскільки він успадковує апендер від `root`). Якби `additivity="false"`, повідомлення потрапило б *тільки* у `File`.

6.  **Практика:** Конкатенація (`"User: " + user.getName()`) змушує Java **завжди** створювати новий рядок, навіть якщо рівень `DEBUG` вимкнений. Це марна трата ресурсів. Плейсхолдери (`"User: {}"`) працюють "ліниво": SLF4J спочатку перевіряє, чи увімкнений рівень `DEBUG`, і *тільки* якщо так — форматує рядок.

7.  **MDC:** Вирішує проблему ідентифікації дій *одного користувача* (або одного запиту) у "змішаному" лог-файлі на сервері. Він працює, прив'язуючи унікальний ідентифікатор (напр., `userId` або `requestId`) до **поточного потоку**. `Layout` (шаблон) автоматично додає цей ідентифікатор до *кожного* повідомлення, згенерованого цим потоком, дозволяючи потім легко відфільтрувати всі дії одного користувача.

</details>