# Лекція 8: "Чорна скринька" вашого додатку. Вступ до логування

## Вступ: Жорстока правда життя

Привіт усім\! Якби ми жили у світі, де програми ніколи не дають збоїв, цієї лекції б не існувало.  Але ми живемо в реальному світі, де:

  * Додаток "зависає" без видимої причини. 
  * Система раптово починає відповідати на запити по 10 секунд, хоча годину тому все "літало". 
  * Помилка, що сталася *зараз*, була спричинена подіями, які відбулися *годину тому*. 

У всіх цих випадках нам відчайдушно потрібна інформація про те, що відбувалося всередині системи.  Цей процес запису "бортового журналу" називається **логуванням**. 

### Головний конфлікт логування

Існує фундаментальне протиріччя:

  * **Розробник (під час "пожежі")** хоче *максимум* інформації. Йому потрібен кожен крок.
  * **Користувач (і система)** хочуть *мінімум* логування. Будь-який запис у лог — це витрати часу CPU та дискових операцій.  (Були випадки, коли надмірне логування сповільнювало систему в 50 разів\! )

Сучасні системи логування вирішують цей конфлікт, дозволяючи нам гнучко керувати рівнем деталізації, в ідеалі — прямо під час роботи додатку. 

-----

## "Зоопарк" фреймворків: Як ми дійшли до SLF4J

Колись у Java-світі панував хаос. Існувало (і досі існує) багато систем логування:

  * **Log4j (v1):** Старий король, колись дуже популярний і добре продуманий. 
  * **`java.util.logging` (JUL):** Вбудований у Java, але менш гнучкий і не такий інтуїтивний, як Log4j. 
  * **Apache Commons Logging (JCL):** Перша спроба створити "адаптер" (фасад), щоб бібліотеки не залежали від конкретної реалізації. 
  * **Logback:** Створений тим самим автором, що й Log4j, як його прямий наступник. 

### Проблема: Залежність бібліотек

Уявіть, що ви пишете бібліотеку. На який фреймворк вам орієнтуватися?  Якщо ви оберете Log4j, а користувач вашої бібліотеки використовує JUL, виникне конфлікт.

### Рішення: Фасад (Facade)

Для вирішення цієї проблеми були створені **фасади**. Фасад — це просто набір інтерфейсів (API), до якого "говорить" ваш код.  А вже під час запуску до цього фасаду підключається реальний "двигун" логування.

Сьогодні промисловим стандартом є **SLF4J (Simple Logging Facade for Java)**. 

**Сучасний стек логування виглядає так:**

1.  **Фасад (API): `SLF4J`** — Ваш код залежить *тільки* від нього.
2.  **Реалізація (Двигун): `Logback`** — Найпоширеніша "нативна" реалізація SLF4J, яка виконує всю важку роботу.  (Альтернатива — Log4j2).

Ваш код: `MyClass.java` -\> `SLF4J API` -\> `Logback (двигун)` -\> `File / Console`

-----

## Три кити логування

Будь-яка потужна система логування (Log4j, Logback) стоїть на трьох основних поняттях:

1.  **Logger (Логер):** *Що* і *де* логувати?
2.  **Appender (Апендер):** *Куди* логувати?
3.  **Layout (Шаблон/Компоновка):** *Як* (в якому форматі) логувати?

### 1\. Logger (Логер)

Логер — це об'єкт, який ви використовуєте у своєму коді для надсилання повідомлень. 

#### Ієрархія

Логери організовані в ієрархію, подібно до пакетів Java, використовуючи крапку як роздільник. 

  * Логер `com.mycompany` є батьком для `com.mycompany.service`.
  * Існує головний, **кореневий (root) логер**, який є батьком для всіх. 

**Найкраща практика:** Отримувати логер за іменем класу, в якому він використовується.

```java
// У класі com.mycompany.service.UserService
private static final Logger logger = LoggerFactory.getLogger(UserService.class);
```

Таким чином, ім'я логера автоматично стає `com.mycompany.service.UserService`. 

#### Рівні логування

Це інструмент, який вирішує наш "головний конфлікт". Ви пишете повідомлення з певним рівнем важливості: 

  * `logger.trace("Дуже детальна інформація для відладки");`
  * `logger.debug("Відлагоджувальна інформація");` 
  * `logger.info("Щось сталося (наприклад, 'Сервер стартував')");` 
  * `logger.warn("Щось пішло не так, але не критично");` 
  * `logger.error("Сталася серйозна помилка");` 

#### Фільтрація та успадкування рівнів

Кожен логер має "ефективний рівень". Якщо ви встановите логеру `com.mycompany` рівень `INFO`, то:

  * Усі повідомлення `TRACE` та `DEBUG` для цього логера (та його нащадків) будуть **проігноровані**. 
  * Усі повідомлення `INFO`, `WARN`, `ERROR` будуть **опубліковані**. 

Якщо логеру рівень не вказано, він **успадковує** його від найближчого батька. 

**Приклад:**
Ви можете встановити `root` рівень `WARN` (для продакшену), але для проблемного модуля `com.mycompany.payment` тимчасово увімкнути `DEBUG`, не чіпаючи решту системи.

### 2\. Appender (Апендер)

Апендер — це кінцевий пункт призначення вашого лог-повідомлення. 
Найпоширеніші типи:

  * `ConsoleAppender`: Виводить у консоль (System.out/err). 
  * `FileAppender`: Пише у файл. 
  * Інші: `DBAppender` (пише в базу даних) , `SocketAppender` (надсилає по мережі) , `SMTPAppender` (надсилає email при `ERROR`).

#### Log Rotation (Ротація логів)

Використовувати простий `FileAppender` небезпечно — він буде рости до нескінченності.  На практиці завжди використовують ротацію:

  * **`RollingFileAppender`:** Ротація за розміром. Коли лог досягає, наприклад, 100MB, він перейменовується в `app.0.log`, а новий `app.log` створюється з нуля. 
  * **`DailyRollingFileAppender`:** Ротація за часом (наприклад, щодня).  Лог за вчора архівується (напр., `app.2025-11-04.log`). 

(Сучасний Logback об'єднує їх в один потужний `RollingFileAppender`).

#### Additivity (Адитивність)

За замовчуванням, логер надсилає повідомлення *своєму* апендеру І *всім апендерам своїх батьків*. 

  * **Приклад:** Якщо `root` пише в `Console`, а `com.mycompany` пише у `File`, то повідомлення для `com.mycompany` потрапить **і у файл, і в консоль**.
  * Іноді це не те, що вам потрібно. Це можна вимкнути, встановивши логеру `additivity="false"`. 

### 3\. Layout (Шаблон/Компоновка)

Layout відповідає за форматування повідомлення.  На практиці 99% часу використовується **`PatternLayout`** — шаблон, який ви налаштовуєте самі. 

**Приклад поганого, нечитабельного логу:**

```
INFO
Some message
ERROR
Another message
DEBUG
...
```

**Приклад гарного, читабельного логу:**

```
2025-11-04 22:30:15,123 [main] INFO  com.my.App - Сервер стартував
2025-11-04 22:30:16,456 [Thread-1] DEBUG com.my.UserService - Знайдено користувача id=123
2025-11-04 22:30:16,457 [Thread-1] ERROR com.my.PaymentService - Помилка платежу!
```

Ця краса досягається завдяки **вирівнюванню** (`%-5p`, `%-16t`, `%.32c`), яке робить лог чистим, як таблиця. 

**Розшифровка типового шаблону:** 

  * `%d{ISO8601}` - Дата і час у форматі ISO. 
  * `[%t]` або `[%-16.16t]` - Ім'я потоку (вирівняне до 16 символів). 
  * `%-5p` - Рівень логування (INFO, DEBUG), вирівняний вліво на 5 символів. 
  * `%c{32}` або `[%32.32c]` - Ім'я логера (категорія), скорочене до 32 символів. 
  * `%m` - Ваше повідомлення. 
  * `%n` - Новий рядок. 

-----

## Найкращі практики та "Killer-feature": MDC

### 1\. `if (logger.isDebugEnabled())`

Коли ви пишете код з конкатенацією:
`logger.debug("Дані: " + user.getName() + " та " + order.getId());`

Цей рядок **завжди буде створено**, навіть якщо у вас в налаштуваннях стоїть рівень `INFO`.  Ви даремно витрачаєте ресурси. Раніше це вирішували так:

```java
if (logger.isDebugEnabled()) {
    logger.debug("Дані: " + user.getName() + " та " + order.getId());
}
```



### 2\. (Сучасне рішення) Плейсхолдери SLF4J

SLF4J вирішує цю проблему елегантно:
`logger.debug("Дані: {} та {}", user.getName(), order.getId());`

SLF4J достатньо розумний, щоб *спочатку* перевірити, чи увімкнено `DEBUG`, і *тільки потім* форматувати рядок. Це швидко і чисто.

### 3\. MDC (Mapped Diagnostic Context)

Це найпотужніший інструмент для відладки.

**Проблема:** У вас веб-сервер. Тисячі користувачів одночасно.  Один з них (наприклад, `user-123`) скаржиться на помилку. Як знайти *саме його* дії у лог-файлі, де все перемішано? 

**Рішення:** MDC — це "мапа" (`Map<String, String>`), прив'язана до *поточного потоку*. 

1.  **На початку запиту** (наприклад, у фільтрі сервлета) ви додаєте контекст:
    `MDC.put("userId", "user-123");` 
2.  Ви додаєте `[%X{userId}]` до свого шаблону `PatternLayout`. 
3.  **Результат:** *Кожне* лог-повідомлення, згенероване *цим потоком* (навіть з бібліотек\!), автоматично отримає префікс `[user-123]`.
    `... [Thread-1] [user-123] ERROR com.my.PaymentService - Помилка платежу!`
4.  **В кінці запиту** (у блоці `finally`) ви *обов'язково* чистите контекст:
    `MDC.remove("userId");` 

Це дозволяє вам миттєво відфільтрувати весь життєвий цикл одного запиту серед мільйонів інших.

-----

## Конфігурація: Приклад (Сучасний `logback.xml`)

Ось як виглядає конфігурація `logback.xml`, яка об'єднує всі ці ідеї:

```xml
<configuration>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} [%X{userId}] - %msg%n</pattern>
    </encoder>
  </appender>

  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/my-app.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <fileNamePattern>logs/my-app.%d{yyyy-MM-dd}.log</fileNamePattern>
      <maxHistory>30</maxHistory>
    </rollingPolicy>
    <encoder>
      <pattern>%d{ISO8601} [%thread] %-5level %logger{36} [%X{userId}] - %msg%n</pattern>
    </encoder>
  </appender>

  <logger name="com.mycompany" level="DEBUG" additivity="false">
    <appender-ref ref="STDOUT" />
    <appender-ref ref="FILE" />
  </logger>

  <logger name="org.hibernate" level="WARN" />

  <root level="INFO">
    <appender-ref ref="STDOUT" />
  </root>

</configuration>
```

-----

## Контрольні питання

1.  **Конфлікт:** Поясніть "головний конфлікт" логування. Як рівні (Levels) допомагають його вирішити?
2.  **Стек:** Назвіть 2 компоненти сучасного стеку логування. Який є "фасадом" (API), а який "двигуном" (реалізацією)?
3.  **Компоненти:** У чому різниця між Логером, Апендером та Шаблоном?
4.  **Ієрархія:** У вас є логер `com.app.service` з рівнем `DEBUG`. Його батько, `com.app`, має рівень `INFO`. Який "ефективний рівень" буде у логера `com.app.service`?
5.  **Additivity:** Якщо `root` логер пише в `Console`, а логер `com.app` пише у `File` (і additivity=true), куди потрапить повідомлення від `com.app`?
6.  **Практика:** Чому `logger.debug("User: " + user.getName());` гірше, ніж `logger.debug("User: {}", user.getName());`?
7.  **MDC:** Поясніть, яку проблему вирішує MDC (Mapped Diagnostic Context) і як він працює (на прикладі `userId`).