# Практикум 6: Модульний дизайн, або Як не писати "крихкий" код (DIP, IoC, DI)

## Вступ

Усі ми хочемо писати код, який можна буде легко перевикористати в інших проектах. 
Є думка, що "коду, що перевикористувується, не існує, але успішні бібліотеки доводять протилежне. Секрет — у грамотній архітектурі.

Сьогодні ми пройдемо шлях від простого, але "крихкого" коду до гнучкого та модульного дизайну. Нашим піддослідним буде **простий бот для Discord**, який надсилає сповіщення. Ми побачимо, як зміна вимог змушує нас переосмислювати наш підхід і застосовувати ключові принципи проектування.

---
## Як це буває в житті: Еволюція нашого Бота

### Версія 1: "Просто, щоб працювало"

Уявімо, що нам потрібно написати бота, який відправляє повідомлення "Привіт!" у конкретний канал. Перша версія, написана "в лоб", може виглядати так:

```java
public class NotificationBot {
    public void sendMessage() {
        String apiToken = "hardcoded-token-from-discord";
        long channelId = 123456789012345678L;
        String message = "Привіт!";

        // Логіка підключення до Discord API та відправки...
        System.out.printf("Надсилаю '%s' в канал %d, використовуючи токен...%n", message, channelId);
    }
}
```

**Проблема:** Цей код жорстко "прив'язаний" до конкретних значень. Щоб змінити повідомлення, канал або токен, потрібно лізти в код і перекомпільовувати програму. Це порушення принципу інверсії залежностей, адже наш модуль "знає" занадто багато деталей про реалізацію.

### Версія 2: "Трохи гнучкості"

**Нова вимога:** Бот повинен вміти надсилати **різні** повідомлення у **різні** канали. Давайте параметризуємо це.

```java
public class NotificationBot {
    private final String apiToken = "hardcoded-token-from-discord";

    public void sendMessage(long channelId, String message) {
        // Логіка відправки...
        System.out.printf("Надсилаю '%s' в канал %d...%n", message, channelId);
    }
}
```

**Стало краще?** Так, але не набагато. Ми все ще прив'язані до одного токену.

### Проблема, що все ламає

**Нова вимога:** Наш бот має працювати на двох серверах — тестовому та робочому, з різними токенами. А ще, в майбутньому, налаштування (токен та ID каналу за замовчуванням) потрібно буде завантажувати **з бази даних**, а не з файлу.

Наш підхід, коли клас сам відповідає за отримання конфігурації, повністю ламається. Це класичний приклад неправильного дизайну, який змушує нас модифікувати код з кожною новою вимогою.

-----

## Як це має бути: Застосовуємо Принципи Дизайну

Щоб вирішити цю проблему, нам потрібно застосувати три ключові концепції.

### Принцип Інверсії Залежностей (DIP)

> **Принцип:** Модулі вищого рівня не повинні залежати від модулів нижчого рівня. Обидва мають залежати від **абстракцій**.

**Простими словами:** Наш `NotificationBot` (вищий рівень) не повинен знати, *звідки* беруться налаштування — з файлу чи з БД (нижчий рівень). Він повинен залежати від простого **"контракту" (інтерфейсу)**, який гарантує, що він отримає потрібні дані.

```java
// Абстракція, від якої всі будуть залежати
public interface BotConfig {
    String getToken();
    long getDefaultChannelId();
}
```

### Принцип Єдиного Обов'язку (SRP)

> **Принцип:** Клас повинен мати лише один обов'язок.

**Простими словами:** Ми маємо відокремити логіку **читання конфігурації** від логіки **відправки повідомлень**. `NotificationBot` має тільки відправляти, а за конфігурацію мають відповідати інші, спеціалізовані класи.

```java
// Цей клас вміє читати конфігурацію тільки з файлу
public class FileBotConfig implements BotConfig {
    // ... реалізація читання з файлу...
}

// Цей клас вміє читати конфігурацію тільки з БД
public class DatabaseBotConfig implements BotConfig {
    // ... реалізація читання з БД...
}
```

### Інверсія Контролю (IoC) та Впровадження Залежностей (DI)

**Інверсія Контролю (IoC)** — це принцип, згідно з яким контроль над створенням залежностей "інвертується". Тепер не Бот створює свою конфігурацію, а хтось ззовні створює її для Бота.

**Впровадження Залежностей (DI)** — це конкретна техніка реалізації IoC. Ми "впроваджуємо" (inject) вже готовий об'єкт конфігурації в наш Бот, наприклад, через конструктор.

-----

## Фінальна версія коду: Гнучкий та модульний Бот

Ось як виглядає наш бот, спроектований за цими принципами.

**1. Абстракція (Інтерфейс):**

```java
// BotConfig.java
public interface BotConfig {
    String getToken();
    long getDefaultChannelId();
}
```

**2. Конкретні реалізації:**

```java
// FileBotConfig.java
public class FileBotConfig implements BotConfig {
    // ... реалізація читання з файлу ...
}

// DatabaseBotConfig.java
public class DatabaseBotConfig implements BotConfig {
    // ... реалізація читання з БД ...
}
```

**3. Високорівневий модуль, що залежить від абстракції:**

```java
// NotificationBot.java
public class NotificationBot {
    private final BotConfig config;

    // Залежність "впроваджується" через конструктор (DI)
    public NotificationBot(BotConfig config) {
        this.config = config;
    }

    public void sendDefaultMessage(String message) {
        String token = config.getToken();
        long channelId = config.getDefaultChannelId();
        System.out.printf("Надсилаю '%s' в канал %d...%n", message, channelId);
    }
}
```

**4. "Збирач" (Assembler), який все поєднує:**

```java
// Main.java
public class Main {
    public static void main(String[] args) {
        // Ми вирішуємо, яку конфігурацію використати, ЗЗОВНІ
        BotConfig config = new FileBotConfig("bot.properties"); // або new DatabaseBotConfig(...)

        // І впроваджуємо її в нашого бота
        NotificationBot bot = new NotificationBot(config);

        bot.sendDefaultMessage("Принципи дизайну - це просто!");
    }
}
```

Тепер наш `NotificationBot` є повністю **модульним**. Він нічого не знає про файли чи бази даних і залежить лише від контракту `BotConfig`. Ми можемо створювати безліч способів конфігурації, не змінюючи жодного рядка у класі `NotificationBot`.

-----

## Контрольні питання

1.  **DIP.** Своїми словами, що означає "залежати від абстракцій, а не від реалізацій" на прикладі нашого Бота?
2.  **SRP.** Який єдиний обов'язок тепер має клас `FileBotConfig` у фінальній версії?
3.  **IoC/DI.** Поясніть різницю між Інверсією Контролю та Впровадженням Залежностей. Хто тепер відповідає за створення об'єкта конфігурації для Бота у фінальній версії коду?
4.  **OCP.** Уявіть, що тепер конфігурацію потрібно завантажувати з хмарного сервісу (наприклад, AWS Parameter Store). Опишіть, які кроки ви зробите, щоб додати цю функціональність. Чи потрібно буде змінювати клас `NotificationBot`?