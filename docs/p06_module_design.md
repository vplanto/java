# Практикум 6: Модульний дизайн, або Як не писати "крихкий" код (DIP, IoC, DI)

## ⚡ Експрес-опитування: Згадуємо SOLID

На [попередньому практикумі](p05_solid.md) ми розбирали "спагеті-код". Давайте пригадаємо:

1.  **"D" (DIP):** Як розшифровується Принцип Інверсії Залежностей?
2.  **Проблема DIP:** Яку проблему ми виявили в `OrderProcessor`, який створював `new MySQLOrderRepository()` всередині себе?
3.  **"S" (SRP):** Чому клас, який одночасно читає конфігурацію з файлу *і* відправляє повідомлення, є поганою ідеєю?

<details markdown="1">
<summary>Наші очікування (відповідь)</summary>

1.  **DIP (Dependency Inversion Principle):** Модулі вищого рівня не повинні залежати від модулів нижчого рівня. Обидва мають залежати від **абстракцій** (інтерфейсів).
2.  **Проблема:** `OrderProcessor` (високий рівень) був жорстко "прив'язаний" до `MySQLOrderRepository` (низький рівень). Щоб змінити базу даних на PostgreSQL, нам довелося б **змінювати** код `OrderProcessor`, що порушує OCP.
3.  **SRP (Single Responsibility Principle):** Це порушення Принципу єдиного обов'язку. Такий клас має **дві причини для змін**: 1) Зміна логіки відправки повідомлень, 2) Зміна формату або розташування файлу конфігурації.

</details>

Сьогодні ми глибоко зануримося саме в ці три концепції: **DIP**, **SRP** та техніку, що їх реалізує — **Dependency Injection (DI)**.

## Вступ

Усі ми хочемо писати код, який можна буде легко перевикористати в інших проектах.
Є думка, що "коду, що перевикористувується, не існує", але успішні бібліотеки доводять протилежне. Секрет — у грамотній архітектурі.

Сьогодні ми пройдемо шлях від простого, але "крихкого" коду до гнучкого та модульного дизайну. Нашим піддослідним буде **простий бот для Discord**, який надсилає сповіщення. Ми побачимо, як зміна вимог змушує нас переосмислювати наш підхід і застосовувати ключові принципи проектування.

Цей практикум є прямим продовженням [Лекції 5](05_solid.md) та [Практикуму 5](p05_solid.md), де ми фокусуємося на найважливішому принципі для створення модульних систем — **Принципі Інверсії Залежностей (DIP)**.

-----

## Як це буває в житті: Еволюція нашого Бота

### Версія 1: "Просто, щоб працювало"

Уявімо, що нам потрібно написати бота, який відправляє повідомлення "Привіт\!" у конкретний канал. Перша версія, написана "в лоб", може виглядати так:

```java
public class NotificationBot {
    public void sendMessage() {
        String apiToken = "hardcoded-token-from-discord";
        long channelId = 123456789012345678L;
        String message = "Привіт!";

        // Логіка підключення до Discord API та відправки...
        System.out.printf("Надсилаю '%s' в канал %d, використовуючи токен...%n", message, channelId);
    }
}
```

**Проблема:** Цей код жорстко "прив'язаний" до конкретних значень. Щоб змінити повідомлення, канал або токен, потрібно лізти в код і перекомпільовувати програму.

### Версія 2: "Трохи гнучкості"

**Нова вимога:** Бот повинен вміти надсилати **різні** повідомлення у **різні** канали. Давайте параметризуємо це.

```java
public class NotificationBot {
    private final String apiToken = "hardcoded-token-from-discord"; // <-- ПРОБЛЕМА ЗАЛИШИЛАСЬ ТУТ

    public void sendMessage(long channelId, String message) {
        // Логіка відправки...
        System.out.printf("Надсилаю '%s' в канал %d...%n", message, channelId);
    }
}
```

**Стало краще?** Так, але не набагато. Ми все ще прив'язані до одного токену.

### Проблема, що все ламає

**Нова вимога:** Наш бот має працювати на двох серверах — тестовому та робочому, з різними токенами. А ще, в майбутньому, налаштування (токен та ID каналу за замовчуванням) потрібно буде завантажувати **з бази даних**, а не з файлу.

Наш підхід, коли клас сам відповідає за отримання конфігурації, повністю ламається. Це класичний приклад неправильного дизайну, який змушує нас модифікувати код з кожною новою вимогою.

-----

## Як це має бути: Застосовуємо Принципи Дизайну

Щоб вирішити цю проблему, нам потрібно застосувати три ключові концепції.

### Принцип Інверсії Залежностей (DIP)

> **Принцип:** Модулі вищого рівня не повинні залежати від модулів нижчого рівня. Обидва мають залежати від **абстракцій**.

**Простими словами:** Наш `NotificationBot` (вищий рівень) не повинен знати, *звідки* беруться налаштування — з файлу чи з БД (нижчий рівень). Він повинен залежати від простого **"контракту" (інтерфейсу)**, який гарантує, що він отримає потрібні дані.

```java
// Абстракція, від якої всі будуть залежати
public interface BotConfig {
    String getToken();
    long getDefaultChannelId();
}
```

### Принцип Єдиного Обов'язку (SRP)

> **Принцип:** Клас повинен мати лише один обов'язок.

**Простими словами:** Ми маємо відокремити логіку **читання конфігурації** від логіки **відправки повідомлень**. `NotificationBot` має тільки відправляти, а за конфігурацію мають відповідати інші, спеціалізовані класи.

```java
// Цей клас вміє читати конфігурацію тільки з файлу
public class FileBotConfig implements BotConfig {
    // ... реалізація читання з файлу...
}

// Цей клас вміє читати конфігурацію тільки з БД
public class DatabaseBotConfig implements BotConfig {
    // ... реалізація читання з БД...
}
```

### Інверсія Контролю (IoC) та Впровадження Залежностей (DI)

**Інверсія Контролю (IoC)** — це принцип, згідно з яким контроль над створенням залежностей "інвертується". Тепер не Бот створює свою конфігурацію, а хтось ззовні створює її для Бота.

**Впровадження Залежностей (DI)** — це конкретна техніка реалізації IoC. Ми "впроваджуємо" (inject) вже готовий об'єкт конфігурації в наш Бот, наприклад, через конструктор.

-----

## Фінальна версія коду: Гнучкий та модульний Бот

Ось як виглядає наш бот, спроектований за цими принципами.

**1. Абстракція (Інтерфейс):**

```java
// BotConfig.java
public interface BotConfig {
    String getToken();
    long getDefaultChannelId();
}
```

**2. Конкретні реалізації:**

```java
// FileBotConfig.java
public class FileBotConfig implements BotConfig {
    // ... реалізація читання з файлу ...
}

// DatabaseBotConfig.java
public class DatabaseBotConfig implements BotConfig {
    // ... реалізація читання з БД ...
}
```

**3. Високорівневий модуль, що залежить від абстракції:**

```java
// NotificationBot.java
public class NotificationBot {
    private final BotConfig config;

    // Залежність "впроваджується" через конструктор (DI)
    public NotificationBot(BotConfig config) {
        this.config = config;
    }

    public void sendDefaultMessage(String message) {
        String token = config.getToken();
        long channelId = config.getDefaultChannelId();
        System.out.printf("Надсилаю '%s' в канал %d...%n", message, channelId);
    }
}
```

**4. "Збирач" (Assembler), який все поєднує:**

```java
// Main.java
public class Main {
    public static void main(String[] args) {
        // Ми вирішуємо, яку конфігурацію використати, ЗЗОВНІ
        BotConfig config = new FileBotConfig("bot.properties"); // або new DatabaseBotConfig(...)

        // І впроваджуємо її в нашого бота
        NotificationBot bot = new NotificationBot(config);

        bot.sendDefaultMessage("Принципи дизайну - це просто!");
    }
}
```

Тепер наш `NotificationBot` є повністю **модульним**. Він нічого не знає про файли чи бази даних і залежить лише від контракту `BotConfig`. Ми можемо створювати безліч способів конфігурації, не змінюючи жодного рядка у класі `NotificationBot`.

-----

## ✅ Контрольні питання

1.  **DIP.** Своїми словами, що означає "залежати від абстракцій, а не від реалізацій" на прикладі нашого Бота?
2.  **SRP.** Який єдиний обов'язок тепер має клас `FileBotConfig` у фінальній версії?
3.  **IoC/DI.** Поясніть різницю між Інверсією Контролю та Впровадженням Залежностей. Хто тепер відповідає за створення об'єкта конфігурації для Бота у фінальній версії коду?
4.  **OCP.** Уявіть, що тепер конфігурацію потрібно завантажувати з хмарного сервісу (наприклад, AWS Parameter Store). Опишіть, які кроки ви зробите, щоб додати цю функціональність. Чи потрібно буде змінювати клас `NotificationBot`?

<details markdown="1">
<summary>Відповіді (спробуйте спочатку відповісти самі)</summary>

1.  **DIP:** Це означає, що клас `NotificationBot` (високий рівень) більше не знає про *конкретні* класи `FileBotConfig` або `DatabaseBotConfig` (низький рівень). Він знає лише про "контракт" — інтерфейс `BotConfig`. Йому байдуже, *звідки* прийде конфігурація, аби вона відповідала цьому контракту.

2.  **SRP:** Його єдиний обов'язок — **"Прочитати конфігурацію бота з файлу"**. Він більше не вміє відправляти повідомлення чи читати з БД.

3.  **IoC/DI:**

      * **IoC (Інверсія Контролю):** Це *принцип*. Раніше `NotificationBot` *сам контролював* створення своєї конфігурації. Тепер цей контроль "інвертований" (переданий назовні).
      * **DI (Впровадження Залежностей):** Це *техніка* реалізації IoC. Ми "впровадили" залежність (`BotConfig`) через конструктор.
      * **Відповідальний:** За створення конфігурації тепер відповідає "третя сторона" — клас `Main` (наш "Збирач" або Assembler).

4.  **OCP:**

    1.  Ми створимо **новий клас** `public class AwsBotConfig implements BotConfig`.
    2.  Всередині нього ми реалізуємо методи `getToken()` та `getDefaultChannelId()`, додавши логіку роботи з AWS SDK.
    3.  У класі `Main` ми змінимо один рядок: `BotConfig config = new AwsBotConfig(...)`.

    <!-- end list -->

      * **Клас `NotificationBot` змінювати не потрібно.** Він залишається "закритим для модифікації", але система виявилася "відкритою для розширення". Ми дотрималися OCP.

</details>