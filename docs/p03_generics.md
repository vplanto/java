# Практикум 3: Вступ до Generics (Узагальнень)

## Вступ: Проблема типізації в колекціях

Уявімо, що нам потрібен список, який має зберігати лише рядки. До появи Generics такий код виглядав би так:

```java
// Старий підхід з використанням Object
List list = new ArrayList();
list.add("Hello");
list.add(123); // Помилка? Ні, компілятор все пропускає!

// ... десь в іншому місці коду ...
// Ми очікуємо отримати рядок, але випадково дістаємо число
String text = (String) list.get(1); // <-- Тут програма впаде з ClassCastException
````

Основна проблема тут — **відсутність безпеки типів**. Компілятор не може гарантувати, що в списку знаходяться лише рядки, і ми дізнаємося про помилку лише під час виконання програми, що є дуже небезпечним.

## Частина 1: Рішення — що таке Generics?

**Generics (узагальнення)** — це механізм, що дозволяє створювати класи, інтерфейси та методи, які можуть працювати з різними типами даних, зберігаючи при цьому **сувору перевірку типів на етапі компіляції**.

Уявіть це як створення шаблону з "пропуском" для типу даних, який буде заповнено при використанні.

**Той самий приклад з використанням Generics:**

```java
// Ми чітко вказуємо, що список може зберігати ТІЛЬКИ рядки
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123); // <-- ПОМИЛКА КОМПІЛЯЦІЇ! Ми врятовані.

// Не потрібно робити явне приведення типів
String text = list.get(0);
```

### Ключові переваги Generics

1.  **Безпека типів на етапі компіляції:** Компілятор одразу знаходить помилки, пов'язані з невідповідністю типів.
2.  **Усунення потреби в явному приведенні типів (Casting):** Код стає чистішим, коротшим і безпечнішим, оскільки зникає ризик отримати `ClassCastException`.

-----

## Частина 2: Створення власного Generic-класу

Ви можете легко створювати власні узагальнені класи. Найпростіший приклад — "коробка", що може зберігати об'єкт будь-якого типу.

**Приклад: Клас `Box<T>`**

```java
// T - це параметр типу (type parameter),
// який буде замінено на конкретний тип при створенні об'єкта
public class Box<T> {
    private T content;

    public void setContent(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }
}
```

**Використання `Box<T>`:**

```java
// Створюємо коробку для Integer
Box<Integer> integerBox = new Box<>();
integerBox.setContent(10);
int number = integerBox.getContent(); // Не потрібно приведення типів

// Створюємо коробку для String
Box<String> stringBox = new Box<>();
stringBox.setContent("Hello Generics");
String message = stringBox.getContent(); // Не потрібно приведення типів
```

-----

## Частина 3: Обмежені параметри типів (Bounded Type Parameters)

Іноді потрібно обмежити типи, які можна використовувати з вашим generic-класом. Наприклад, створити "коробку", яка може зберігати лише числові типи (`Integer`, `Double` тощо).

**Приклад: `NumberBox<T extends Number>`**

```java
// T може бути будь-яким типом, що є нащадком класу Number
public class NumberBox<T extends Number> {
    private T number;

    public NumberBox(T number) {
        this.number = number;
    }

    public double doubleValue() {
        return number.doubleValue(); // Ми впевнені, що метод doubleValue() існує
    }
}

// Використання
NumberBox<Integer> intBox = new NumberBox<>(10);
NumberBox<Double> doubleBox = new NumberBox<>(5.5);
// NumberBox<String> stringBox = new NumberBox<>("text"); // ПОМИЛКА КОМПІЛЯЦІЇ!
```

-----

### \#\# Порівняння з C++ Templates

Хоча Generics у Java схожі на шаблони (templates) у C++, між ними є фундаментальна різниця.

  * **Java (Стирання типів / Type Erasure):** Інформація про узагальнений тип (`<String>`, `<Integer>`) **стирається** компілятором і не існує під час виконання. Для JVM `List<String>` та `List<Integer>` — це просто `List`.
  * **C++ (Генерація коду):** Компілятор C++ **генерує окремий код** для кожного конкретного типу, що використовується з шаблоном.

Ця різниця пояснює, чому в Java, наприклад, не можна зробити `new T()`, оскільки під час виконання JVM не знає, що таке `T`.

-----

## Контрольні питання

1.  **Концепція.** Назвіть дві основні переваги використання Generics у Java.
2.  **Застосування.** Напишіть простий узагальнений клас `Pair<K, V>`, який може зберігати два об'єкти різних типів (ключ та значення).
3.  **Порівняння.** У чому полягає ключова відмінність між Generics у Java та шаблонами (templates) у C++?
4.  **Обмеження.** Як створити generic-метод `calculateSum`, який приймає список (`List`) будь-яких об'єктів, що є нащадками класу `Number`, і повертає їхню суму у вигляді `double`? Напишіть сигнатуру цього методу.
