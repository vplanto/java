# Практикум 3: Вступ до Generics (Узагальнень)

## ⚡ Експрес-опитування: Згадуємо основи

На [попередньому практикумі](p02_class.md) ми обговорювали класи та інтерфейси.

1.  У C++ ви використовували `template <typename T> class Box {...}`. Яку проблему це вирішувало?
2.  На [Лекції 2](02_collections_intro.md) ми бачили ієрархію колекцій, де `List` та `Set` походять від `Collection`. Який тип даних, на вашу думку, зберігає `Collection` "під капотом", щоб мати можливість тримати в собі *будь-що*?

<details markdown="1">
<summary>Наші очікування (відповідь)</summary>

1.  Це дозволяло створити один клас `Box`, який міг би працювати з різними типами (`Box<int>`, `Box<string>`), не дублюючи код.
2.  До появи Generics, всі колекції в Java зберігали об'єкти типу **`Object`** (оскільки `Object` є батьком для *всіх* класів у Java). Це дозволяло додати в `List` і рядок, і число, і будь-який інший об'єкт.

</details>

Сьогодні ми подивимося, яку проблему створював цей підхід з `Object` і як Java вирішила її за допомогою **Generics**.

## Вступ: Проблема типізації в колекціях

Уявімо, що нам потрібен список, який має зберігати лише рядки. До появи Generics (до Java 5), такий код виглядав би так:

```java
// Старий підхід з використанням Object
List list = new ArrayList();
list.add("Hello");
list.add(123); // Помилка? Ні, компілятор все пропускає! (бо 123 - це Integer, а Integer - це Object)

// ... десь в іншому місці коду ...
// Ми очікуємо отримати рядок, але випадково дістаємо число
String text = (String) list.get(1); // <-- Тут програма впаде з ClassCastException
```

Основна проблема тут — **відсутність безпеки типів**. Компілятор не може гарантувати, що в списку знаходяться лише рядки, і ми дізнаємося про помилку лише під час виконання програми, що є дуже небезпечним.

## Частина 1: Рішення — що таке Generics?

**Generics (узагальнення)** — це механізм, що дозволяє створювати класи, інтерфейси та методи, які можуть працювати з різними типами даних, зберігаючи при цьому **сувору перевірку типів на етапі компіляції**.

Уявіть це як створення шаблону з "пропуском" для типу даних, який буде заповнено при використанні.

**Той самий приклад з використанням Generics:**

```java
// Ми чітко вказуємо, що список може зберігати ТІЛЬКИ рядки
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123); // <-- ПОМИЛКА КОМПІЛЯЦІЇ! Ми врятовані.

// Не потрібно робити явне приведення типів
String text = list.get(0);
```

### Ключові переваги Generics

1.  **Безпека типів на етапі компіляції:** Компілятор одразу знаходить помилки, пов'язані з невідповідністю типів.
2.  **Усунення потреби в явному приведенні типів (Casting):** Код стає чистішим, коротшим і безпечнішим, оскільки зникає ризик отримати `ClassCastException`.

-----

## Частина 2: Створення власного Generic-класу

Ви можете легко створювати власні узагальнені класи. Найпростіший приклад — "коробка", що може зберігати об'єкт будь-якого типу.

**Приклад: Клас `Box<T>`**

```java
// T - це параметр типу (type parameter),
// який буде замінено на конкретний тип при створенні об'єкта
public class Box<T> {
    private T content;

    public void setContent(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }
}
```

**Використання `Box<T>`:**

```java
// Створюємо коробку для Integer
Box<Integer> integerBox = new Box<>();
integerBox.setContent(10);
int number = integerBox.getContent(); // Не потрібно приведення типів

// Створюємо коробку для String
Box<String> stringBox = new Box<>();
stringBox.setContent("Hello Generics");
String message = stringBox.getContent(); // Не потрібно приведення типів
```

-----

## Частина 3: Обмежені параметри типів (Bounded Type Parameters)

Іноді потрібно обмежити типи, які можна використовувати з вашим generic-класом. Наприклад, створити "коробку", яка може зберігати лише числові типи (`Integer`, `Double` тощо).

**Приклад: `NumberBox<T extends Number>`**

```java
// T може бути будь-яким типом, що є нащадком класу Number
public class NumberBox<T extends Number> {
    private T number;

    public NumberBox(T number) {
        this.number = number;
    }

    public double doubleValue() {
        // Ми впевнені, що метод doubleValue() існує,
        // оскільки всі нащадки Number зобов'язані його мати
        return number.doubleValue();
    }
}

// Використання
NumberBox<Integer> intBox = new NumberBox<>(10);
NumberBox<Double> doubleBox = new NumberBox<>(5.5);
// NumberBox<String> stringBox = new NumberBox<>("text"); // ПОМИЛКА КОМПІЛЯЦІЇ!
```

-----

## Частина 4: Порівняння з C++ Templates

Хоча Generics у Java схожі на шаблони (templates) у C++, між ними є фундаментальна різниця.

  * **Java (Стирання типів / Type Erasure):** Інформація про узагальнений тип (`<String>`, `<Integer>`) **стирається** компілятором і не існує під час виконання. Для JVM `List<String>` та `List<Integer>` — це просто `List`.
  * **C++ (Генерація коду):** Компілятор C++ **генерує окремий код** для кожного конкретного типу, що використовується з шаблоном.

Ця різниця пояснює, чому в Java, наприклад, не можна зробити `new T()`, оскільки під час виконання JVM не знає, що таке `T`.

-----

## ✅ Контрольні питання

1.  **Концепція.** Назвіть дві основні переваги використання Generics у Java.
2.  **Застосування.** Напишіть простий узагальнений клас `Pair<K, V>`, який може зберігати два об'єкти різних типів (ключ та значення).
3.  **Порівняння.** У чому полягає ключова відмінність між Generics у Java та шаблонами (templates) у C++?
4.  **Обмеження.** Як створити generic-метод `calculateSum`, який приймає список (`List`) будь-яких об'єктів, що є нащадками класу `Number`, і повертає їхню суму у вигляді `double`? Напишіть сигнатуру цього методу.

<details markdown="1">
<summary>Відповіді (спробуйте спочатку відповісти самі)</summary>

1.  **Переваги Generics:**

    1.  **Безпека типів на етапі компіляції:** Компілятор не дозволить додати `Integer` до `List<String>`.
    2.  **Усунення потреби в явному приведенні типів:** Нам не потрібно писати `(String) list.get(0)`, що запобігає `ClassCastException`.

2.  **Клас `Pair<K, V>`:**

    ```java
    public class Pair<K, V> {
        private K key;
        private V value;

        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public K getKey() { return key; }
        public V getValue() { return value; }
    }
    ```

3.  **Різниця:** Generics в Java використовують **"стирання типів" (Type Erasure)** — уся інформація про типи (як `<String>`) видаляється під час компіляції. Шаблони (Templates) в C++ використовують **генерацію коду** — компілятор створює окрему копію класу для кожного типу.

4.  **Сигнатура методу:**

    ```java
    // <T extends Number> - це оголошення обмеженого generic-типу для цього методу
    public <T extends Number> double calculateSum(List<T> list) {
        double sum = 0.0;
        for (T number : list) {
            sum += number.doubleValue(); // Ми можемо викликати .doubleValue(), бо T є нащадком Number
        }
        return sum;
    }
    ```

    *Альтернативне (і більш гнучке) рішення могло б використовувати "wildcard":*
    `public double calculateSum(List<? extends Number> list)`

</details>