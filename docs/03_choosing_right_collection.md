# Лекція 3: Як обрати правильну колекцію

## ⚡ Експрес-опитування: Згадуємо інтерфейси

На [попередній лекції](02_collections_intro.md) ми познайомилися з основними "родинами" колекцій. Давайте швидко перевіримо:

1.  Вам потрібно зберігати список елементів, де **порядок важливий** і **дублікати дозволені**. Який інтерфейс ви оберете?
2.  Вам потрібно зберігати **тільки унікальні** елементи, порядок не має значення. Який інтерфейс ви оберете?
3.  Вам потрібно зберігати пари "ID користувача" -> "Об'єкт користувача" для швидкого пошуку. Який інтерфейс ви оберете?

<details markdown="1">
<summary>Наші очікування (відповідь)</summary>

1.  **`List`**. Класичний приклад — `ArrayList`.
2.  **`Set`**. Класичний приклад — `HashSet`.
3.  **`Map`**. Класичний приклад — `HashMap`.

</details>

Сьогодні ми перейдемо на наступний рівень: від вибору *інтерфейсу* до вибору **конкретної реалізації**.

## Алгоритм вибору інтерфейсу

Вибір правильної колекції — це двокроковий процес. Спочатку ми обираємо найбільш відповідний **інтерфейс** (`List`, `Set`, `Map`, `Queue`) на основі логічних вимог задачі, а потім — найкращу **конкретну реалізацію** цього інтерфейсу, враховуючи очікувану продуктивність.

Ось проста схема, що допоможе обрати правильний інтерфейс:

-----

### Опис схеми вибору інтерфейсу

Ця схема є алгоритмом для вибору правильного базового інтерфейсу з Java Collections Framework на основі вимог вашої задачі. Процес прийняття рішень виглядає так:

1.  **Потреба у зберіганні пар "ключ-значення"**:
      * **Так**: Ваш вибір — **`Map`**. На цьому вибір інтерфейсу завершено.
      * **Ні**: Переходьте до наступного кроку.
2.  **Потреба у збереженні порядку додавання елементів**:
      * **Так**: Ваш вибір — **`List`**.
      * **Ні**: Переходьте до наступного кроку.
3.  **Потреба у специфічному доступі (LIFO, FIFO, за пріоритетом)**:
      * **Так**: Ваш вибір — **`Queue`**.
      * **Ні**: Переходьте до наступного кроку.
4.  **Потреба у зберіганні дублікатів**:
      * **Так**: Ваш вибір — **`List`**.
      * **Ні**: Ваш вибір — **`Set`**.

-----

### Схема у форматі Mermaid

```mermaid
graph TD;
    Start(( )) --> Q1{"Need key-value pairs?"};
    Q1 -- "Yes" --> A_Map[Map];
    Q1 -- "No" --> Q2{"Traversal according to insertion order?"};
    Q2 -- "Yes" --> A_List[List];
    Q2 -- "No" --> Q3{"LIFO, FIFO, remove by priority?"};
    Q3 -- "Yes" --> A_Queue[Queue];
    Q3 -- "No" --> Q4{"Duplicate elements present?"};
    Q4 -- "Yes" --> A_List;
    Q4 -- "No" --> A_Set[Set];
```

**Ключові питання для вибору інтерфейсу:**

  * Вам потрібно зберігати пари "ключ-значення"? → **`Map`** 
  * Вам потрібна послідовність елементів зі збереженням порядку вставки? → **`List`** 
  * Вам потрібна структура для обробки елементів (FIFO, LIFO, за пріоритетом)? → **`Queue`** 
  * Вам потрібно зберігати унікальні елементи? → **`Set`** 

-----

## Порівняння реалізацій: List

#### Внутрішня структура

  * **`ArrayList`** всередині використовує звичайний **масив**. Це робить доступ до елемента за індексом миттєвим, але вставка чи видалення елементів з середини списку є повільною операцією, оскільки вимагає копіювання частини масиву.
  * **`LinkedList`** використовує структуру **зв'язаного списку**, де кожен елемент (вузол) зберігає посилання на сусідні елементи. Це робить вставку та видалення елементів дуже швидкими, але доступ за індексом вимагає послідовного проходження по ланцюжку.

#### Таблиця продуктивності (Big O)

| Реалізація | Додавання/видалення на початку/середині | Додавання/видалення в кінці | Отримання i-го елемента (доступ за індексом) | Пошук елемента | Порядок обходу |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **`ArrayList`** | `O(n)`  | `O(1)`  | `O(1)`  | `O(n)` (або `O(log n)`, якщо відсортовано)  | Порядок вставки  |
| **`LinkedList`** | `O(1)`  | `O(1)`  | `O(n)`  | `O(n)`  | Порядок вставки  |

-----

## Порівняння реалізацій: Set

#### Внутрішня структура

  * **`HashSet`** використовує **хеш-таблицю**. Це забезпечує найвищу швидкість додавання та пошуку, але не гарантує жодного порядку елементів.
  * **`LinkedHashSet`** — це гібрид **хеш-таблиці та зв'язаного списку**. Він такий же швидкий, як `HashSet`, але додатково підтримує порядок вставки елементів.
  * **`TreeSet`** використовує **червоно-чорне дерево**. Це гарантує, що елементи завжди зберігаються у відсортованому вигляді. Швидкість операцій дещо нижча (`O(log n)`).
  * **`EnumSet`** — високооптимізована реалізація для зберігання значень `enum`.

#### Таблиця продуктивності (Big O)

| Реалізація | Додавання | Видалення | Пошук | Порядок обходу |
| :--- | :--- | :--- | :--- | :--- |
| **`HashSet`** | амортизований `O(1)`  | амортизований `O(1)`  | `O(1)`  | Випадковий (залежить від хеш-функції)  |
| **`LinkedHashSet`** | амортизований `O(1)`  | амортизований `O(1)`  | `O(1)`  | Порядок вставки  |
| **`TreeSet`** | `O(log n)`  | `O(log n)`  | `O(log n)`  | Відсортований (за критерієм порівняння)  |
| **`EnumSet`** | `O(1)`  | `O(1)`  | `O(1)`  | Порядок визначення `enum`  |

-----

## Порівняння реалізацій: Queue

Реалізації черг можна розділити на дві групи:

  * **`LinkedList`**, **`ArrayDeque`**: Універсальні реалізації, що можуть працювати як черга (FIFO), стек (LIFO) або двостороння черга (deque). Загалом, **`ArrayDeque` є швидшим**, ніж `LinkedList`, і є кращим вибором за замовчуванням .
  * **`PriorityQueue`**: Спеціалізована черга, що базується на структурі даних **бінарна купа**. Вона дозволяє дуже швидко (`O(1)`) отримувати елемент з найвищим пріоритетом. Додавання та видалення елементів працює за `O(log n)` .

-----

## Порівняння реалізацій: Map

| Реалізація | Додавання | Видалення | Пошук | Порядок обходу |
| :--- | :--- | :--- | :--- | :--- |
| **`HashMap`** | амортизований `O(1)`  | амортизований `O(1)`  | `O(1)`  | Випадковий (залежить від хеш-функції)  |
| **`LinkedHashMap`** | амортизований `O(1)`  | амортизований `O(1)`  | `O(1)`  | Порядок вставки  |
| **`TreeMap`** | `O(log n)`  | `O(log n)`  | `O(log n)`  | Відсортований (за ключами)  |
| **`EnumMap`** | `O(1)`  | `O(1)`  | `O(1)`  | Порядок визначення `enum` (за ключами)  |

-----

## Детальна схема вибору реалізації

Ця схема узагальнює процес вибору конкретної реалізації, враховуючи більш детальні вимоги.

-----

### Опис детальної схеми вибору реалізації

Ця схема є розширеним алгоритмом, що допомагає обрати конкретну реалізацію колекції після того, як ви визначились із базовим інтерфейсом.

#### **Якщо вам потрібен `Map` (зберігання "ключ-значення"):** 

  * **Чи важливий порядок обходу елементів відповідно до порядку їх додавання?** 
      * **Так:** Ваш вибір — **`LinkedHashMap`**.
      * **Ні:** Переходьте до наступного питання.
  * **Чи потрібно, щоб елементи були відсортовані (за ключами)?** 
      * **Так:** Ваш вибір — **`TreeMap`**.
      * **Ні:** Переходьте до наступного питання.
  * **Чи є ваші ключі перелічуваним типом (`enum`)?** 
      * **Так:** Ваш вибір — **`EnumMap`**.
      * **Ні:** Ваш вибір — **`HashMap`** (найшвидший універсальний варіант).

#### **Якщо вам не потрібен `Map`:**

  * **Чи розглядаєте ви елементи як лінійну послідовність (як у `List`)?** 
      * **Так (тобто вам потрібен `List`):**
          * **Чи потрібні часті вставки/видалення елементів на початку або в середині списку?** 
              * **Так:** Ваш вибір — **`LinkedList`**.
              * **Ні:** Ваш вибір — **`ArrayList`** (швидший для доступу за індексом).
      * **Ні (тобто вам потрібен `Set` або `Queue`):**
          * **Чи важливий порядок обходу елементів відповідно до порядку їх додавання?** 
              * **Так:** Ваш вибір — **`LinkedHashSet`**.
              * **Ні:** Переходьте до наступного питання.
          * **Чи дозволені у вашій колекції дублікати?** 
              * **Так:** Поверніться до питання про лінійну послідовність (швидше за все, вам потрібен `List`).
              * **Ні:** Переходьте до наступного питання.
          * **Чи потрібна поведінка черги (LIFO/FIFO)?** 
              * **Так:** Ваш вибір — **`ArrayDeque`** або **`LinkedList`**.
              * **Ні:** Переходьте до наступного питання.
          * **Чи потрібне видалення елементів за пріоритетом?** 
              * **Так:** Ваш вибір — **`PriorityQueue`**.
              * **Ні (тобто вам потрібен `Set`):**
                  * **Чи є ваші значення перелічуваним типом (`enum`)?** 
                      * **Так:** Ваш вибір — **`EnumSet`**.
                      * **Ні:** Ваш вибір — **`HashSet`**.

-----

### Схема у форматі Mermaid

```mermaid
graph TD;
    Q_Start(( )) --> Q_IsMap{"Need key-value pairs?"};

    subgraph "Гілка Map"
        Q_IsMap -- "Yes" --> Q_MapOrder{"Traversal according to insertion order?"};
        Q_MapOrder -- "Yes" --> R_LinkedHashMap(LinkedHashMap);
        Q_MapOrder -- "No" --> Q_MapSort{"Need sorting?"};
        Q_MapSort -- "Yes" --> R_TreeMap(TreeMap);
        Q_MapSort -- "No" --> Q_MapEnum{"Keys are enums?"};
        Q_MapEnum -- "Yes" --> R_EnumMap(EnumMap);
        Q_MapEnum -- "No" --> R_HashMap(HashMap);
    end

    subgraph "Гілка List / Set / Queue"
        Q_IsMap -- "No" --> Q_IsLinear{"Elements treated as linear sequence?"};
        
        subgraph "Підгілка List"
            Q_IsLinear -- "Yes" --> Q_ListInsert{"Need frequent insertion in the beginning or middle?"};
            Q_ListInsert -- "Yes" --> R_LinkedList(LinkedList);
            Q_ListInsert -- "No" --> R_ArrayList(ArrayList);
        end

        subgraph "Підгілка Set & Queue"
            Q_IsLinear -- "No" --> Q_SetOrder{"Traversal according to insertion order?"};
            Q_SetOrder -- "Yes" --> R_LinkedHashSet(LinkedHashSet);
            Q_SetOrder -- "No" --> Q_Duplicates{"Duplicate elements present?"};
            Q_Duplicates -- "Yes" --> Q_IsLinear;
            Q_Duplicates -- "No" --> Q_IsQueue{"LIFO, FIFO?"};
            Q_IsQueue -- "Yes" --> R_Queue(ArrayDeque, LinkedList);
            Q_IsQueue -- "No" --> Q_Priority{"Removal by priority?"};
            Q_Priority -- "Yes" --> R_PriorityQueue(PriorityQueue);
            Q_Priority -- "No" --> Q_FinalSet{"Values are enums?"};
            Q_FinalSet -- "Yes" --> R_EnumSet(EnumSet);
            Q_FinalSet -- "No" --> R_HashSet(HashSet);
        end
    end
```

-----

## Порівняння колекцій на рівність

  * Колекція може бути рівною лише іншій колекції того ж типу (`List` до `List`, `Set` до `Set`, `Map` до `Map`) .
  * `SortedSet` може бути рівним `Set`, а `SortedMap` — `Map` .
  * Для перевірки на рівність за певним критерієм може знадобитися конвертація одного типу колекції в інший.

| Якщо важливий... | Тип для порівняння |
| :--- | :--- |
| Впорядкований вміст з дублікатами | `List`  |
| Невпорядкований вміст з дублікатами | `Map` (частот)  |
| Відсортований вміст з дублікатами | `List` (попередньо відсортований)  |
| Унікальний вміст | `Set`  |

-----

## Практичне застосування

Найкращий спосіб закріпити цю теорію — подивитися, як різні типи колекцій (List, Set та Map) працюють разом для вирішення реальної задачі. Саме це ми і зробимо на наступному практикумі: [Практикум 4: Симулятор 'Банки' Monobank](p04_collections.md)

Вітаю, Віталію\!

Ви абсолютно праві, моя попередня перевірка була некоректною. Я виправив форматування секції "Контрольні питання" у файлі `03_choosing_right_collection.md`, щоб питання були видимими, а всі відповіді — приховані в одному блоці.

Ось виправлена секція:

-----

## ✅ Контрольні питання

1.  **Сценарій.** Вам потрібно зберігати історію дій користувача в тому порядку, в якому вони відбувалися. Дії можуть повторюватися. Який **інтерфейс** та яку **конкретну реалізацію** ви оберете і чому?
2.  **Продуктивність.** Чому операція додавання елемента в середину `ArrayList` має складність O(n), а в `LinkedList` — O(1)? Поясніть, базуючись на їхній внутрішній структурі.
3.  **Концепція.** Ви хочете зберігати унікальні об'єкти, але вам важливо обходити їх у тому порядку, в якому ви їх додали. Яку реалізацію `Set` ви оберете і чому?

<details markdown="1">
<summary>Відповіді (спробуйте спочатку відповісти самі)</summary>

1.  **Інтерфейс:** `List`, оскільки він гарантує порядок вставки та дозволяє дублікати.
    **Реалізація:** `ArrayList`. Хоча `LinkedList` має швидке додавання в кінець (`O(1)`), `ArrayList` також має амортизований `O(1)` для додавання в кінець, але при цьому набагато швидший для *читання* та ітерації, що для *історії* дій зазвичай є частішою операцією.

2.  **`ArrayList` (O(n)):** Всередині `ArrayList` знаходиться масив. Щоб вставити елемент в середину (наприклад, на позицію 5 у списку з 100 елементів), потрібно "посунути" всі елементи, що йдуть після нього (з 5-го по 99-й), на одну позицію вправо, щоб звільнити місце. Це операція копіювання масиву, складність якої лінійно залежить від кількості елементів (`n`).
    **`LinkedList` (O(1)):** Всередині `LinkedList` — це ланцюжок вузлів. Кожен вузол знає свого "сусіда". Щоб вставити новий елемент, нам потрібно лише змінити два посилання: "попередній" вузол тепер вказує на наш новий, а наш новий вказує на "наступний". Кількість елементів у списку на цю операцію не впливає. (Примітка: це `O(1)`, *якщо* ми вже маємо ітератор на потрібній позиції. Пошук позиції сам по собі займає `O(n)`).

3.  **`LinkedHashSet`**.

      * **Чому `Set`:** Бо потрібно зберігати унікальні об'єкти.
      * **Чому `LinkedHashSet`:** Звичайний `HashSet` не гарантує жодного порядку. `TreeSet` сортує елементи, що нам не потрібно. `LinkedHashSet` — це гібрид, який використовує хеш-таблицю для швидкого додавання/пошуку (`O(1)`) і водночас підтримує зв'язаний список, що фіксує **порядок вставки**.

</details>