# Лекція 5: NFR Discovery. Чому «додамо потім» не працює

**Аудиторія:** 2-й курс (Junior Strong)
**Ціль:** Показати на реальних прикладах, що відбувається, коли NFR виявляються після старту розробки. Навчити збирати NFR до написання першого рядка коду.

> **English version:** [English](en/05_nfr_late_discovery.md)

---

## 1. Відкрита дискусія (Warm-up)

Сценарій для обговорення:

> Команда 3 місяці будує платформу для онлайн-аукціонів. Розробники написали бізнес-логіку ставок, реалізували авторизацію, зробили красивий UI. На demo замовник задоволений.
>
> І тут: «До речі, нам треба підтримувати 50,000 одночасних ставок за секунду у пікові моменти. Це ж не проблема?»

Питання до групи:

1. Що саме зараз «не так» в архітектурі?
2. Скільки з написаного коду доведеться викинути?
3. Хто винен і що треба було зробити інакше?

<details markdown="1">
<summary>Розгорнути аналіз</summary>

50,000 ставок/секунду — це ~50,000 TPS на write-операцію. PostgreSQL з типовою конфігурацією: 1,000-5,000 TPS. Різниця — на порядок.

Що треба переробити:
- БД: або перейти на інше рішення (Cassandra, Redis + PostgreSQL), або кардинально переробити схему і indexing стратегію.
- Серверна частина: Stateless-архітектура (якщо не зробили), горизонтальне масштабування, черга (Kafka/RabbitMQ) щоб не губити ставки під пік.
- Бізнес-логіка: аукціонну логіку «хто виграв» треба переписати з урахуванням eventual consistency.
- UI: WebSocket або Server-Sent Events замість polling, інакше під пік клієнти «смітять» запитами.

Тобто «не змінюється» — тільки HTML і CSS.

Хто винен: усі. Розробники не запитали. Архітектор не зупинив. Замовник не сказав. Але найдорожча помилка сталась саме тому, що NFR не збирали *до* архітектурних рішень.

</details>

---

## 2. Вартість пізнього NFR: та сама логіка, що з багами

У Лекції 2 ми бачили таблицю вартості виправлення помилок:

```
Час виявлення→              Вартість виправлення
Requirements               $1
Design                     $10
Development                $100
Testing                    $1,000
Production                 $10,000+
```

Для NFR — та сама крива, але з іншим нахилом.

```
Коли виявлено NFR →            Що доводиться міняти
До Design                  Вибір технологій, схема БД (дешево)
Під час Development        Рефакторинг шарів, перехід на async (боляче)
На Testing (Load test)     Переписування гарячих шляхів, індекси, кеш (дорого)
На Production (інцидент)   Аварійна міграція під навантаженням (дуже дорого)
Після скейлінгу            Повна переробка архітектури (починаємо з нуля)
```

Різниця між «до Design» і «після скейлінгу» — це різниця між 1x і 100x зусиль.

### Реальний кейс: Twitter Rewrite 2008-2009

Twitter запустився як Rails-монолітне застосування. Архітектура не проєктувалась під масштаб — функціонал будувався «щоб працювало».

До 2008 року Twitter падав щомісяця. «Fail Whale» — сторінка про помилку — стала мемом. Система не витримувала реального навантаження.

Наслідок: повна переробка бекенду. Перехід з Ruby on Rails на Scala/JVM. Окремі сервіси для timeline, search, notifications. Це тривало роки.

Коштувало б дешевше, якби NFR були зібрані перед архітектурними рішеннями 2006 року? Дискусійно — тоді ніхто не знав, наскільки виросте платформа. Але сьогодні у вас є ці кейси. У розробників Twitter 2006 — не було.

---

## 3. Чому NFR «забувають» на старті: три типові помилки

### Помилка 1: «Спочатку зробимо, потім оптимізуємо»

Ця фраза має сенс для локальних оптимізацій (конкретний алгоритм, конкретний SQL-запит). Вона не має сенсу для архітектурних рішень.

Якщо ви обрали монолітну архітектуру і реляційну БД для задачі, яка вимагає eventual consistency і горизонтального масштабування — «оптимізувати» не вийде. Треба переписувати.

Правило: алгоритми оптимізують пізніше. Архітектуру — ніколи.

### Помилка 2: «Замовник не знає, скільки буде користувачів»

Замовник дійсно не знає точну цифру. Але замовник знає бізнес-контекст:

- «Це внутрішній інструмент для 20 менеджерів» → зовсім інша архітектура, ніж
- «Це публічна платформа, яку ми плануємо партнерам в 5 країнах»

Навіть приблизний порядок величин — 10 або 10,000 користувачів — кардинально змінює рішення. Завдання інженера — витягти цей контекст, навіть якщо замовник «не знає».

### Помилка 3: «NFR — задача DevOps, вони потім налаштують»

<details markdown="1">
<summary>Чому DevOps не «виправить» погану архітектуру</summary>

DevOps може налаштувати балансувальник і автоскейлінг. Але якщо застосування Stateful (зберігає сесії в пам'яті), масштабування додаванням нод не допоможе — кожен новий сервер не «знає» про сесії на інших.

DevOps може налаштувати Redis-кластер. Але якщо код робить N+1 queries до БД, Redis не прибере проблему — він тільки зрушить її.

DevOps може добавити CDN. Але якщо API повертає 10MB JSON замість 10KB, CDN буде кешувати повільну відповідь.

Інфраструктура підсилює архітектуру — хорошу чи погану. Вона не замінює її.

</details>

---

## 4. NFR Discovery: як витягти вимоги до початку розробки

### 4.1 П'ять ключових питань

Перед будь-яким архітектурним рішенням — отримайте відповідь на ці питання:

**1. Навантаження:**
«Скільки одночасних користувачів у звичайний день? У пік?»
«Які операції виконуються найчастіше: читання чи запис?»
«Очікується зростання x10 за рік? За 3 роки?»

**2. Доступність:**
«Що станеться, якщо система буде недоступна 1 годину вночі? Вдень?»
«Є плановий регламент технічного обслуговування? Довжина?»
«SLA з клієнтом є? Які штрафи?»

**3. Дані:**
«Скільки записів у найбільшій таблиці сьогодні? Через рік?»
«Як довго зберігаються дані? Є вимога на видалення?»
«Дані критично-важливі для відновлення після збою? RTO/RPO?»

**4. Безпека:**
«Хто має доступ до яких даних?»
«Є регуляторні вимоги (GDPR, PCI DSS)?»
«Зберігаємо персональні дані чи фінансові?»

**5. Зміни:**
«Наскільки часто бізнес-логіка змінюється?»
«Хто буде підтримувати систему через 2 роки — ця команда чи нова?»

### 4.2 Техніка: NFR Workshop

Замість того щоб просити NFR у документ — проводьте 2-годинний NFR Workshop зі стейкхолдерами.

Формат: фасилітатор (архітектор або тімлід) по черзі задає питання категорій NFR. Кожна відповідь фіксується і отримує числовий критерій.

Приклад діалогу на Workshop:

> «Система повинна бути доступна 24/7»
> 
> — «Що означає "доступна"? 99.9% або 99.99%?»
> — «І хто платить за різницю в 10x вартості інфраструктури?»
> — «Якщо система падає о 3 ночі на 5 хвилин — бізнес постраждає?»

Після таких питань «24/7» перетворюється на «99.5% availability, planned maintenance вночі допускається, SLA без штрафів».

---

## 5. NFR-перший дизайн: зміни порядку роботи

Типова помилка послідовності:

```
❌ Стандартний підхід:
FR збір → UI Mockups → Database Schema → API Design → NFR обговорення
                                                             ↑
                                              (занадто пізно!)
```

Правильний підхід:

```
✅ NFR-First підхід:
NFR Workshop
    ↓
Capacity Estimation (back-of-the-envelope)
    ↓
Architectural Decision Records (ADR)  ← "Чому PostgreSQL, а не Cassandra"
    ↓
Database Schema Design
    ↓
API Design
    ↓
FR деталізація
```

NFR стоять першими — бо вони обмежують всі наступні рішення. Не навпаки.

### Architectural Decision Records (ADR)

ADR — короткий документ, який фіксує: яке рішення прийнято, чому, і від яких альтернатив відмовились.

```markdown
# ADR-001: Використовуємо PostgreSQL як основну БД

## Статус: Прийнято (2024-03-15)

## Контекст
Система обробляє 500 RPS переважно read-операцій (80/20).
NFR: P99 latency < 200мс, availability 99.9%.
Команда: 3 Backend, жодного досвіду з NoSQL.

## Рішення
PostgreSQL + Read Replica + Redis-кеш для hot-path запитів.

## Відкинуті альтернативи
- MongoDB: команда без досвіду, ризик для термінів.
- Cassandra: оverkill для 500 RPS, складна операційно.

## Наслідки
- Горизонтальне масштабування write-операцій обмежене.
- При зростанні >5,000 RPS — переглянути через 6 місяців.
```

ADR виглядає як додаткова робота. Насправді це страховка: через 6 місяців новий член команди не запитуватиме «чому не Mongo» і не переписуватиме систему, не знаючи причин.

---

## 6. Ознаки NFR-проблеми в «живому» коді

Якщо ви прийшли в команду і хочете зрозуміти, чи проблема з NFR є — ось де шукати:

**Ознаки проблем з Performance:**
- Запити до БД без LIMIT у pagination.
- N+1 queries (SELECT в циклі).
- Відсутність індексів на полях WHERE і JOIN.
- JSON-відповіді понад 1MB без пагінації.

**Ознаки проблем з Scalability:**
- Стан зберігається в пам'яті інстанції (in-memory session).
- Файли записуються на локальний диск сервера.
- Scheduled jobs запускаються на кожній ноді одночасно.

**Ознаки проблем з Availability:**
- Немає health check endpoint.
- Немає graceful shutdown (процес вбивається без завершення запитів).
- Немає retry логіки при зверненні до зовнішніх сервісів.

**Ознаки проблем з Security:**
- SQL через string concatenation.
- Паролі в .properties файлах, які є в Git.
- Відсутній rate limiting на публічних ендпоінтах.

---

## 7. Практика: NFR Audit власного проєкту

<details markdown="1">
<summary>Чек-ліст для аудиту — розгорнути</summary>

Пройдіться по кожному пункту для вашого поточного або минулого проєкту:

**Performance:**
- [ ] Є конкретний P99 latency target для кожного критичного ендпоінта?
- [ ] Проводився load testing з реалістичним навантаженням?
- [ ] Є профайлер-результати? Де найповільніші точки?

**Scalability:**
- [ ] Застосування Stateless? (тест: можна вбити довільну ноду?)
- [ ] Яке максимальне навантаження пройдено без деградації?
- [ ] Є план дій при x10 поточного навантаження?

**Availability:**
- [ ] Є моніторинг з alerting (не «перевіряємо руками»)?
- [ ] Є runbook для типових інцидентів?
- [ ] Проводився chaos testing (тест на відмову компонентів)?

**Security:**
- [ ] Всі залежності перевіряються на CVE (Snyk, Dependabot)?
- [ ] Є penetration testing у плані?
- [ ] Персональні дані шифруються в стані спокою?

**Maintainability:**
- [ ] Unit test coverage > 70% для бізнес-логіки?
- [ ] Є процедура rollback при невдалому деплої?
- [ ] Чи може новий розробник задеплоїти без допомоги?

Якщо більше 3 відповідей «Ні» або «Не знаю» — є NFR-борг.

</details>

---

## 8. Екзаменаційний пул (Exam Questions)

**Питання 1: Розробники кажуть: «Спочатку зробимо MVP, потім оптимізуємо». Коли це прийнятна стратегія, а коли — небезпечна помилка?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

Прийнятно для MVP: відкладати UI-полірування, деякі edge cases, повну локалізацію, розширену аналітику. Ці речі дійсно можна додати пізніше без переробки архітектури.

Небезпечно: відкладати рішення про масштабування, схему зберігання стану, механізм авторизації, вибір черги повідомлень. Ці рішення «просочуються» через весь код. Переробити їх пізніше означає переписати систему.

Різниця: якщо пізніша зміна вимагає редагування >30% кодової бази або зміни контракту API — це не оптимізація, це переробка.

</details>

**Питання 2: Замовник каже: «Не знаю, скільки буде користувачів». Як ви вилучаєте NFR в такій ситуації?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

Замовник не знає точних цифр, але знає бізнес-контекст. Питання для витягування:

«Це внутрішній інструмент чи публічний сервіс?» → порядок: десятки vs мільйони.
«Скільки зараз активних клієнтів у бізнесі?» → верхня межа для першої версії.
«Є плани масштабуватись на інші регіони?» → хрест чи ні.
«Що найгірше може статися, якщо система «впаде»?» → SLA вимога від зворотного.

З відповідей отримуємо приблизний ORDER OF MAGNITUDE: ~100 vs ~10,000 vs ~1,000,000 користувачів. Цього достатньо для прийняття архітектурних рішень з правильним запасом.

</details>

**Питання 3: Що таке Architectural Decision Record (ADR)? Навіщо фіксувати «чому ні» поряд із «чому так»?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

ADR — короткий документ, що фіксує: контекст, прийняте рішення, відкинуті альтернативи, наслідки.

«Чому ні» важливіше «чому так»: через 6 місяців новий розробник бачить PostgreSQL і думає «чому не Kafka?». Якщо ADR містить «Kafka відкинута: команда без досвіду, навантаження 500 RPS, не виправдано», — розробник не витратить тиждень на «пропозицію перейти на Kafka».

ADR запобігає «архітектурній амнезії» — коли через рік ніхто не пам'ятає, чому обрали ті чи інші рішення, і починають їх переглядати без контексту.

</details>

**Питання 4: Команда виявила на production, що система не витримує навантаження. DevOps пропонує «просто додати більше серверів». Коли це вирішить проблему, а коли — ні?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

Додавання серверів вирішить проблему, якщо: застосування Stateless, bottleneck — CPU або мережа, і не виникне проблем з прямолінійним масштабуванням.

Не вирішить, якщо: застосування Stateful (sticky sessions — нові сервери не мають стану), bottleneck в БД (усі сервери пишуть в один PostgreSQL — додавання апп-серверів погіршить ситуацію), або є global lock в коді (наприклад, synchronized блок у Java — більше серверів тільки збільшать contention).

Тест: якщо при подвоєнні кількості серверів throughput НЕ подвоюється — bottleneck не в апп-шарі.

</details>

---

**[⬅️ Лекція 4: NFRs](04_nfr.md)** | **[Лекція 6: QA Strategy ➡️](06_qa_strategy.md)**

**[⬅️ Повернутися до головного меню курсу](index.md)**
