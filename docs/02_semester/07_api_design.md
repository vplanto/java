# Лекція 7: API Design. Як будувати контракти між системами

**Аудиторія:** 2-й курс (Junior Strong)
**Ціль:** Навчитись проєктувати REST API так, щоб він лишався зрозумілим, стабільним і не ламав клієнтів при кожній зміні.

> **English version:** [English](en/07_api_design.md)

---

## 1. Відкрита дискусія (Warm-up)

**Сценарій:** Ваша команда написала API. Мобільний додаток, який його використовує, зроблений іншою командою в іншому місті. Ви вирішуєте перейменувати поле `user_name` на `username` — це ж логічніше.

Питання: що відбудеться з мобільним додатком?

<details markdown="1">
<summary>Розгорнути відповідь</summary>

Додаток впаде або почне повертати `null` замість імені користувача. Бо код клієнта очікує поле `user_name`, якого більше немає.

Якщо додаток вже опублікований в App Store — ви не можете «просто попросити користувачів оновитись». Там ще є люди на версії 6-місячної давнини.

API — це публічний контракт. Порушення контракту — це не «дрібна зміна», це зламана система для всіх клієнтів, які від вас залежать.

Сьогодні розберемо, як проєктувати API так, щоб не потрапляти в такі ситуації.

</details>

---

## 2. Що таке API і чому REST

API (Application Programming Interface) — контракт взаємодії між системами. REST (Representational State Transfer) — архітектурний стиль для побудови цього контракту поверх HTTP.

REST не є стандартом (немає RFC для REST самого по собі). Це набір принципів, описаних Роєм Філдінгом у дисертації 2000 року.

Чому REST переміг: використовує HTTP, JSON, легко кешується, людино-читабельний, не вимагає спеціальних клієнтів.

Альтернативи: GraphQL (гнучкіший, але складніший), gRPC (швидший для internal, але binary protocol), SOAP (банки та enterprise legacy — не треба плутатись).

---

## 3. Ресурси і методи: граматика REST

REST мислить ресурсами (іменниками), а не діями (дієсловами).

**Неправильно (RPC-стиль поверх HTTP):**
```
POST /createUser
POST /getUserById
POST /deleteUserAccount
POST /updateUserEmail
```

**Правильно (ресурс-орієнтований):**
```
POST   /users          → створити користувача
GET    /users/{id}     → отримати одного
GET    /users          → список (з пагінацією)
PUT    /users/{id}     → повне оновлення
PATCH  /users/{id}     → часткове оновлення
DELETE /users/{id}     → видалити
```

### HTTP-методи і їх семантика

| Метод | Семантика | Idempotent? | Safe? |
| :--- | :--- | :--- | :--- |
| GET | Отримати ресурс | ✅ Так | ✅ Так |
| POST | Створити ресурс | ❌ Ні | ❌ Ні |
| PUT | Замінити ресурс повністю | ✅ Так | ❌ Ні |
| PATCH | Частково оновити | ❌ Ні | ❌ Ні |
| DELETE | Видалити | ✅ Так | ❌ Ні |

**Idempotent** — повторний виклик дає той самий результат. `DELETE /users/1` викликаний двічі: перший раз видаляє, другий — 404. Кінцевий стан однаковий.

**Safe** — запит не змінює стан системи. `GET` тільки читає.

<details markdown="1">
<summary>Чому idempotency важлива в ненадійних мережах</summary>

Клієнт відправив `POST /orders` — запит пішов, але відповідь не повернулась (timeout мережі). Клієнт не знає: замовлення створено чи ні?

Якщо POST не idempotent і клієнт повторить запит — буде два замовлення. Для цього використовуються Idempotency Keys:

```http
POST /orders
Idempotency-Key: 550e8400-e29b-41d4-a716

{"product_id": 42, "quantity": 1}
```

Сервер запам'ятовує ключ. Якщо прийде повторний запит з тим самим ключем — поверне попередній результат без повторного створення.

</details>

---

## 4. HTTP Status Codes: відповіді зі змістом

HTTP-коди — це частина контракту. Якщо ви повертаєте 200 на помилку або 500 на помилку клієнта — ви порушуєте контракт.

### Основні групи

```
2xx — Успіх
  200 OK             — стандартна успішна відповідь
  201 Created        — ресурс створено (POST)
  204 No Content     — успішно, але відповіді немає (DELETE)

4xx — Помилка клієнта (ВАШ запит неправильний)
  400 Bad Request    — невалідні дані в запиті
  401 Unauthorized   — потрібна авторизація
  403 Forbidden      — авторизований, але немає прав
  404 Not Found      — ресурс не знайдено
  409 Conflict       — конфлікт стану (наприклад, email вже існує)
  422 Unprocessable  — синтаксично правильно, але семантично невалідно
  429 Too Many Req.  — rate limit перевищено

5xx — Помилка сервера (НАША проблема)
  500 Internal Error — щось зламалось на сервері
  502 Bad Gateway    — проблема з upstream сервісом
  503 Unavailable    — сервер перевантажений або на maintenance
```

### Типові помилки з кодами

**Антипатерн: 200 на помилку**
```json
HTTP/1.1 200 OK
{"status": "error", "message": "User not found"}
```
Клієнт не може відрізнити успіх від помилки без парсингу тіла. Моніторинг не бачить проблем.

**Антипатерн: 500 на помилку клієнта**
```json
HTTP/1.1 500 Internal Server Error
{"message": "Invalid email format"}
```
Клієнт думає, що сервер зламався, хоча просто надіслав неправильний email.

---

## 5. Дизайн URL: іменники, ієрархія, консистентність

### Правила іменування ресурсів

```
✅  /users                 — множина для колекцій
✅  /users/{id}            — ідентифікатор у path
✅  /users/{id}/orders     — вкладений ресурс
✅  /orders?status=PENDING — фільтр через query params
✅  /users?page=2&limit=20 — пагінація через query params

❌  /getUser               — дієслово в URL
❌  /user                  — однина для колекції
❌  /users/{id}/getOrders  — дієслово у вкладеному ресурсі
❌  /Users                 — upper case
```

### Коли ієрархія — правильне рішення

```
GET /users/{userId}/orders       — замовлення конкретного користувача
GET /orders/{orderId}/items      — товари в конкретному замовленні
```

Але не треба будувати нескінченну ієрархію:

```
❌  /users/{id}/orders/{orderId}/items/{itemId}/reviews
```

Якщо ієрархія глибша 3 рівнів — розгляньте окремий ресурс верхнього рівня.

---

## 6. Request та Response: що і як передавати

### JSON структура і іменування

```json
// ✅ Правильно: snake_case, описові поля
{
  "user_id": 42,
  "first_name": "Аліна",
  "last_name": "Коваль",
  "email": "alina@example.com",
  "created_at": "2024-03-15T10:30:00Z",
  "is_premium": true
}

// ❌ Уникати: скорочення, незрозумілі поля
{
  "uid": 42,
  "fn": "Аліна",
  "ln": "Коваль",
  "e": "alina@example.com",
  "ts": 1710498600,
  "prem": 1
}
```

### Формат помилок — консистентний

Завжди повертайте помилку в одному форматі — клієнти навчаються парсити один формат:

```json
HTTP/1.1 422 Unprocessable Entity
{
  "error": {
    "code": "VALIDATION_FAILED",
    "message": "Дані не пройшли перевірку",
    "details": [
      {
        "field": "email",
        "message": "Невалідний формат email"
      },
      {
        "field": "phone",
        "message": "Поле обов'язкове"
      }
    ]
  }
}
```

### Пагінація

```json
GET /users?page=2&limit=20

{
  "data": [...],
  "pagination": {
    "page": 2,
    "limit": 20,
    "total": 157,
    "total_pages": 8,
    "has_next": true,
    "has_prev": true
  }
}
```

---

## 7. Версіонування API: контракт не можна змінити, можна замінити

Будь-який публічний API колись потрібно змінити. Версіонування — спосіб не зламати старих клієнтів при цьому.

### Три підходи

**Через URL (найпоширеніший):**
```
/api/v1/users
/api/v2/users
```

Плюси: очевидно, легко в документації та логах.
Мінуси: не «REST-pure» (версія не є частиною ресурсу).

**Через заголовок:**
```http
GET /users
Accept: application/vnd.api.v2+json
```

Плюси: URL чистий. Мінуси: важко тестувати в браузері, менш прозоро.

**Через query parameter:**
```
/users?api_version=2
```

Не рекомендується: query params призначені для фільтрації, а не версіонування.

### Стратегія: що є breaking change?

Breaking change — будь-яка зміна, що ламає існуючих клієнтів:

```
BREAKING (вимагає нова версія):
  - Видалення поля з відповіді
  - Перейменування поля
  - Зміна типу поля (string → int)
  - Зміна семантики існуючого endpoint
  - Видалення endpoint

NON-BREAKING (нова версія не потрібна):
  - Додавання нового поля у відповідь
  - Додавання нового endpoint
  - Додавання нового необов'язкового параметра
```

<details markdown="1">
<summary>Postels Law і чому клієнти мають ігнорувати невідомі поля</summary>

Postel's Law (принцип надійності): «Будь ліберальним до того, що приймаєш, і консервативним до того, що відправляєш».

Якщо ваш JSON-парсер падає на невідомих полях — ви порушили цей принцип. Клієнти мають ігнорувати поля, які не знають. Тоді server може додавати нові поля без breaking changes.

У Java: Jackson за замовчуванням ігнорує невідомі поля. Але якщо хтось написав `@JsonProperty(required = true)` на нові поля — новий клієнт зламає старих.

</details>

---

## 8. OpenAPI (Swagger): API як документ і контракт

OpenAPI — стандарт опису REST API у форматі YAML або JSON. З ним можна:
- Генерувати інтерактивну документацію (Swagger UI).
- Генерувати клієнтський код (openapi-generator).
- Валідувати запити та відповіді автоматично.

```yaml
openapi: 3.0.3
info:
  title: User Service API
  version: "1.0"
paths:
  /users/{id}:
    get:
      summary: Отримати користувача за ID
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        "404":
          description: Користувача не знайдено
components:
  schemas:
    User:
      type: object
      properties:
        user_id:
          type: integer
        email:
          type: string
          format: email
```

**Contract-First підхід:** спочатку пишемо OpenAPI-специфікацію, потім генеруємо заглушки коду. Обидві команди (Frontend і Backend) домовляються про контракт до старту розробки і можуть працювати паралельно.

---

## 9. Екзаменаційний пул (Exam Questions)

**Питання 1: Поясніть різницю між PUT і PATCH. Чому важливо обирати правильно?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

PUT — повна заміна ресурсу. Ви передаєте всі поля. Якщо поле відсутнє в запиті — воно скидається в null або дефолт.

PATCH — часткове оновлення. Ви передаєте тільки ті поля, які змінюються. Решта залишається без змін.

Помилка: використовувати PUT для часткового оновлення. Клієнт, що хоче змінити тільки email, мав надіслати весь об'єкт — або ризикує обнулити ім'я і телефон.

</details>

**Питання 2: Поясніть різницю між 401 і 403. Наведіть конкретний сценарій для кожного.**

<details markdown="1">
<summary>Еталонна відповідь</summary>

401 Unauthorized: система не знає, хто ви. JWT-токен відсутній або протермінований. Рішення клієнта: надіслати Authorization-заголовок або перелогінитись.

403 Forbidden: система знає, хто ви, але ви не маєте прав. Авторизований менеджер регіону Lviv намагається переглянути замовлення регіону Kyiv. Рішення клієнта: немає — це не технічна помилка, а бізнес-правило.

Плутанина між ними — поширена в проєктах без чіткої моделі авторизації.

</details>

**Питання 3: Що таке breaking change в API? Наведіть 2 приклади breaking і 2 приклади non-breaking змін.**

<details markdown="1">
<summary>Еталонна відповідь</summary>

Breaking: видалення поля `user_name` з відповіді (клієнт, що його читав, отримає null або виняток); перейменування endpoint `/users` на `/accounts` (клієнти отримають 404).

Non-breaking: додавання нового поля `middle_name` у відповідь (клієнти, що не знають про нього, просто ігнорують); додавання нового endpoint `/users/{id}/preferences` (старі клієнти не знають про нього, але не ламаються).

</details>

**Питання 4: Команда хоче змінити формат дати в API з Unix timestamp (`1710498600`) на ISO 8601 (`2024-03-15T10:30:00Z`). Це breaking change? Як провести міграцію без downtime?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

Так, це breaking change: тип даних змінився з integer на string. Клієнт, що очікував число і перетворював його через `new Date(timestamp * 1000)`, отримає NaN.

Міграція без breaking change:
1. Додати нове поле `created_at_iso` поряд із `created_at` (Unix). Non-breaking — нові клієнти використовують нове поле, старі — ігнорують.
2. Задокументувати deprecation `created_at` з терміном — наприклад, 6 місяців.
3. Після 6 місяців — прибрати старе поле у v2.

Ключовий принцип: нове поле замість заміни старого, з явним deprecation period.

</details>

---

**[⬅️ Лекція 6: QA Strategy](06_qa_strategy.md)** | **[Лекція 8: Test Cases & Coverage ➡️](08_test_cases.md)**

**[⬅️ Повернутися до головного меню курсу](index.md)**
