# Методологія "Vibe Coding": Від Ідеї до Продукту в Епоху AI

**Версія:** 1.0
**Статус:** Експериментальний протокол
**Ролі:** Студент (Product Owner & AI Operator) vs Ментор (System Architect)

---

## 1. Філософія: Чому ми це робимо?

Ми відмовляємось від класичної моделі навчання *"вивчи синтаксис циклу for -> напиши калькулятор"*. У 2025 році синтаксис — це товар, вартість якого наближається до нуля.

**Нова реальність:**
* **Vibe Coding:** Ви фокусуєтесь на *ідеї* ("вайбі") та *кінцевому результаті*.
* **AI as Workforce:** Чорнову роботу з написання коду виконують LLM (Claude, ChatGPT, GitHub Copilot).
* **Human as Architect:** Ваша задача — не писати код, а **проектувати систему**, формулювати вимоги та валідувати результат.

> **Правило:** Ви можете не написати жодного рядка коду руками. Але ви зобов'язані розуміти і могти пояснити кожен рядок, який згенерував AI.

---

## 2. Workflow: Життєвий цикл проекту

Процес розробки ділиться на 4 етапи. Ваша оцінка залежить від проходження "Quality Gates" між ними.

### Етап 1: The Pitch (Студент)
Ви приходите не з ТЗ, а з ідеєю.
* *Приклад:* "Хочу застосунок для трекінгу поливу квітів, щоб він нагадував Тамагочі".
* *Артефакт:* Короткий опис (One-pager) проблеми, яку вирішуємо.

### Етап 2: Architectural Review (Ментор + Студент)
Я (як Архітектор) допомагаю вам перетворити "вайб" на інженерні вимоги. Ми не обговорюємо кольори кнопок. Ми обговорюємо дані та процеси.
* **Декомпозиція:** Які сутності потрібні? (`Plant`, `Schedule`, `WateringEvent`).
* **Обмеження:** Де зберігаємо фото? (S3 чи Base64 в базі? Чому Base64 — це погано?).
* **Контракти:** Який API ми будуємо?

### Етап 3: AI Implementation (Студент + AI)
Ви йдете "в поля" з AI. Ви використовуєте промпт-інжиніринг, щоб згенерувати рішення.
* **Інструменти:** Cursor, Bolt.new, v0.dev, ChatGPT.
* **Задача:** Отримати працюючий прототип (MVP), який можна запустити.
* **Важливо:** Ви повинні змусити AI дотримуватись архітектури, затвердженої на Етапі 2, а не просто "згенерувати що-небудь".

### Етап 4: The Defense (Ментор vs Студент)
Найжорсткіший етап. Ви показуєте працюючий продукт. Я проводжу **Code Audit**.
* Я питаю: *"Чому тут використано `ArrayList`, а не `Set`?"*
* Я питаю: *"Що буде, якщо API поверне 500 помилку? Покажи мені обробку в коді."*
* Якщо ви не можете пояснити рішення, яке згенерував AI — **PR відхиляється**.

---

## 3. Правила гри (Rules of Engagement)

### Дозволено
1.  Використовувати будь-які AI-моделі.
2.  Копіювати код з StackOverflow чи документації.
3.  Починати проект з готових бойлерплейтів.

### Заборонено (Red Flags)
1.  **"Magic Code":** Залишати в проекті шматки коду, призначення яких ви не розумієте ("Воно працює, я не чіпав").
2.  **Hardcode Credentials:** Токени та паролі в коді (AI любить це робити).
3.  **God Objects:** Класи на 1000 рядків типу `MainManager`. AI схильний скидати логіку в одну купу — ваша задача це рефакторити.
4.  **Blind Trust:** Вірити коментарям, які згенерував AI. Вони часто брешуть.

---

## 4. Критерії оцінювання

Ми оцінюємо не кількість написаних символів, а якість інженерних рішень:

1.  **Product Vision:** Чи вирішує додаток заявлену проблему?
2.  **System Design:** Наскільки чиста архітектура (відсутність спагеті-коду, правильний неймінг).
3.  **AI Ownership:** Наскільки впевнено студент захищає згенерований код.
4.  **Deployment:** Продукт має бути доступним в інтернеті (Render/Vercel/AWS), а не тільки на `localhost`.

---

## 5. Приклад взаємодії (Simulation)

> **Студент:** "Зробив чат. Ось код."
>
> **Ментор:** "Бачу файл `ChatController`. Там є метод `sendMessage`. AI написав там `Thread.sleep(1000)`. Навіщо?"
>
> **Студент (Погано):** "Ну... AI так написав, мабуть, щоб не перевантажувати сервер." -> **Fail.**
>
> **Студент (Добре):** "Це милиця для імітації затримки мережі. У продакшні це треба прибрати, замінивши на асинхронну чергу." -> **Pass.**