# Лекція 1: Архітектура Сучасних Web-застосунків. Екосистема Spring

**Тип:** Engineering Deep Dive
**Рівень:** Junior Strong / Middle
**Мета:** Змінити мислення з "як написати контролер" на "як спроєктувати масштабовану систему". Розуміння вартості архітектурних рішень (SSR vs SPA).

---

##  Експрес-опитування: Інженерний Mindset

Перш ніж писати код, оцінимо фізику процесів.

1.  **Traffic Cost:** Уявіть, що Instagram при кожному лайку перезавантажує всю сторінку (HTML+CSS+Images). Як це вплине на рахунок за хмарний трафік (AWS Egress Cost)?
2.  **Latency:** Чому користувач у метро (Edge/3G) проклинає SSR (Server-Side Rendering), але нормально користується SPA (Single Page Application)?
3.  **Security:** Ми віддаємо JSON. Чи бачить клієнт структуру нашої БД?

<details markdown="1">
<summary>Відповіді (Самоперевірка)</summary>

1.  **Катастрофічно.** Трафік зросте у 100-500 разів. Передача чистого JSON (`{"status": "liked"}` — 20 байт) проти повної сторінки (2-5 МБ). У масштабах Instagram це мільйони доларів втрат.
2.  **Payload Size.** SPA завантажує "оболонку" один раз. Далі бігають лише легкі пакети даних. При SSR кожен клік тягне важку верстку, що на поганому інтернеті робить додаток неюзабельним.
3.  **Ні (якщо ви не помилилися).** Ми використовуємо DTO (Data Transfer Objects). Якщо ви віддасте Entity напряму — ви розкриєте схему БД. Це архітектурна вразливість.

</details>

---

## 1. Еволюція Архітектури: Битва за Ефективність


Ми не обираємо технології "бо це модно". Ми обираємо їх, виходячи з **Non-Functional Requirements (NFR)**: Scalability, Latency, Maintainability.

### 1.1. Legacy: Server-Side Rendering (Monolith)
Старий підхід (JSP, PHP, Servlet API), де сервер формує HTML.
* **Engineering Flaw (Вада):** Coupling (Зв'язність). Сервер знає про верстку.
* **Scalability issue:** CPU сервера витрачається на генерацію тексту HTML, замість обробки бізнес-транзакцій.
* **Клієнт:** "Тупий" термінал, просто показує картинку.

### 1.2. Modern: Headless Architecture & SPA
Розділення відповідальності.
* **Backend (Spring Boot):** Це API. Його продукт — дані (JSON). Він **Stateless**. Йому байдуже, хто клієнт.
* **Frontend (React/Angular):** Це повноцінний застосунок, що виконується на CPU клієнта.
* **Protocol:** HTTP/REST.

> **Engineering Rule:** "Never make the server do what the client can do." Ми перекладаємо рендеринг на пристрої користувачів (Distributed Computing), економлячи свій CPU.

---

## 2. Spring Framework: Dependency Injection як захист архітектури

Чому ми не пишемо `new UserService()`? Це питання не стилю, а **Maintainability**.

### 2.1. Inversion of Control (IoC)
Коли ви пишете `new`, ви "приварюєте" одну деталь до іншої намертво.
У Enterprise-системах це неприпустимо, бо:
1.  **Testing:** Ви не зможете підмінити базу даних на "InMemory Mock" для Unit-тестів.
2.  **Flexibility:** Зміна реалізації вимагає перекомпіляції всього ланцюжка викликів.

**Рішення Spring:**
Контейнер (Application Context) сам створює об'єкти (Beans) і зв'язує їх.
* **Ви:** Описуєте "контракт" (Interface).
* **Spring:** Знаходить реалізацію і робить "Wiring" (зв'язування).


### 2.2. Ціна магії (Runtime Overhead)
Чи безкоштовно це? Ні.
* **Startup Time:** Spring сканує класи при запуску (Reflection API). Це займає час (секунди).
* **Memory Footprint:** Контейнер споживає RAM для зберігання метаданих бінів.
* **Висновок:** Для мікросервісів, що живуть довго — це ОК. Для AWS Lambda (Serverless), де важливий старт за мілісекунди — Spring Boot може бути заважким (тут краще GraalVM).

---

## 3. Spring Boot: Optimization of Developer Time

У бізнесі найдорожчий ресурс — це **час інженера**, а не час процесора.
Spring Boot вирішує проблему **Time-to-Market**.

### 3.1. Starter Packs vs Dependency Hell
* **Без Boot:** Інженер витрачає 2 дні на узгодження версій бібліотек (`jackson 2.9` конфліктує з `spring-web 4.3`).
* **З Boot:** `spring-boot-starter-web`. Одна залежність. "Опінійна" (Opinionated) збірка. Всі версії протестовані сумісно.

### 3.2. Auto-Configuration
Це не магія, це **Conditional Logic**.
Псевдокод того, як працює Boot:
```java
if (classpath.contains("PostgreSQL-Driver") && !beans.contains("DataSource")) {
    createPostgresConnectionPool(); // Автоматичне налаштування
}

```

Це дозволяє підняти Production-ready сервіс за 15 хвилин, а не за 2 тижні.

### 3.3. Embedded Server (Docker Friendly)
Замість зовнішнього Tomcat, сервер вшито в JAR.
Це робить додаток **Cloud Native**.

* Process Isolation: Кожен сервіс має свій сервер.
* Kubernetes: Легко масштабувати (просто запустити ще один Pod).

---

##  Engineering Case Study: Валідація даних
**Ситуація:**
Ви розробляєте фінтех-додаток. Потрібно перевірити, що сума переказу > 0.
Студент пропонує: *"Давайте перевіримо це на Frontend в JavaScript, щоб не навантажувати сервер".*

**Завдання:** Проведіть "Attack Simulation" і поясніть, чому цього недостатньо.

<details markdown="1">
<summary>Архітектурне рішення</summary>

**Відмова.** Рішення студента — критична вразливість (Critical Severity).

1. **Threat Model:** Клієнт знаходиться в "ворожому середовищі". Зловмисник може:
* Відключити JS у браузері.
* Відправити запит напряму через `Postman` або `curl`, минаючи UI.
* Модифікувати клієнтський код.


2. **Принцип:** **Zero Trust.**
* Frontend валідація — це **UX** (ввічливість до юзера, швидкий фідбек).
* Backend валідація — це **Security** (гарантія цілісності даних).


3. **Рішення:** Дублювання логіки. Frontend підсвічує поле червоним. Backend кидає `400 Bad Request`, якщо дані криві.

</details>

---

##✅ Контрольні питання (AI-Resistant Assessment)
*Ці питання перевіряють розуміння, а не пам'ять. Гугл не дасть прямої відповіді.*

1. **Trade-off:** Ви вирішили не використовувати Spring Boot, а писати на "голому" Java Servlet API. Назвіть один сценарій, де це архітектурно виправдано у 2025 році?
2. **Debug:** Ви отримали `404 Not Found` від свого API. Але в логах сервера чисто (немає Exception). Де архітектурно сталася помилка: у DispatcherServlet чи у вашому бізнес-сервісі?
3. **Scalability:** Чому архітектура SPA+REST API масштабується краще, ніж JSF/JSP (Server-Side), якщо у нас різко побільшало користувачів?

<details markdown="1">
<summary>Відповіді</summary>

1. **Extreme Low Latency / High Frequency Trading.** Де оверхед на рефлексію Spring та обгортки об'єктів (Proxy) є неприпустимим (потрібні наносекунди, а не мілісекунди). Або для дуже обмежених Embedded пристроїв (хоча там Java рідкість).
2. **DispatcherServlet.** Він прийняв запит, перевірив список мапінгів (`@RequestMapping`), не знайшов відповідного контролера і одразу віддав 404. До вашого бізнес-коду (Service) виконання навіть не дійшло.
3. **Statelessness.** У SPA сервер не зберігає стан сесії відображення (View State). Кожен запит атомарний. Це дозволяє поставити Load Balancer і додати хоч 1000 нових серверів без складної синхронізації сесій між ними.

</details>