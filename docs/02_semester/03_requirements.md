# Лекція 3: Definition of Requirements. Як перекласти «хочу» на мову інженерії

**Аудиторія:** 2-й курс (Junior Strong)
**Ціль:** Навчити розрізняти чітку вимогу від розмитого побажання, писати User Stories, ставити правильні питання замовникові та виявляти приховані вимоги до того, як почати код.

> **English version:** [English](en/03_requirements.md) | **Незнайоме слово?** → [Глосарій курсу](glossary.md)

---

## 1. Відкрита дискусія (Warm-up)

**Контекст:** Уявіть, що ви — розробник. До вас підходить замовник і каже:

> «Зробіть, щоб сайт був швидким і зручним. І щоб виглядав сучасно.»

Питання до аудиторії: що саме ви будете робити? З чого почнете?

<details markdown="1">
<summary>Розгорнути відповідь</summary>

З такого ТЗ неможливо написати жодного рядка коду, не зробивши помилку. «Швидко», «зручно», «сучасно» — це не вимоги. Це слова.

Класичний наслідок такого старту: розробник робить те, що вважає правильним. Замовник отримує не те, що хотів. Починаються переговори, постановка нових задач, переробка. Бюджет закінчується раніше за проєкт.

Специфікація вимог — це не бюрократія. Це страховий поліс для обох сторін.

</details>

## 2. Що таке вимога і чому «зробити красиво» — не вимога

Вимога (requirement) — це опис того, що система *повинна робити* або *яким умовам відповідати*. Якщо цього немає в документі — цього немає в проєкті.

### Три ознаки поганої вимоги

Погана вимога зазвичай:

- **Суб'єктивна.** «Сайт має бути красивим» — що це означає? Для дизайнера і для ректора університету відповідь різна.
- **Неперевірна.** «Система повинна добре працювати» — як перевірити? Який тест доведе, що вимога виконана?
- **Неоднозначна.** «Користувач може переглядати замовлення» — всі замовлення чи тільки свої? За будь-який період чи за місяць?

### Три ознаки хорошої вимоги

Хороша вимога:

- **Атомарна.** Описує одну річ, не дві.
- **Перевірна.** Можна написати тест-кейс.
- **Зрозуміла всім сторонам.** Dev, QA, PO — читають одне й те саме.

---

## 3. Функціональні вимоги: що система робить

Функціональні вимоги (Functional Requirements, FR) описують поведінку системи: які дії вона виконує, як реагує на вхідні дані.

### Формат написання: від «хочу» до «зробити»

Поганий запис:
> «Система має надсилати листи.»

Хороший запис:
> «Система надсилає email-підтвердження на вказану адресу протягом 30 секунд після успішної реєстрації користувача. У листі: тема "Ласкаво просимо", тіло — ім'я користувача та посилання для підтвердження email.»

Різниця очевидна: другий варіант можна одразу перевірити.

### Реальні провали через погані вимоги

<details markdown="1">
<summary>Кейс: NASA Mars Climate Orbiter ($327M втрат)</summary>

1999 рік. Команда Lockheed Martin передавала навігаційні дані в одиницях фунт-сила·секунд, команда NASA очікувала ньютон·секунд. В документі не було специфіки одиниць вимірювання.

Апарат увійшов в атмосферу Марса під неправильним кутом і згорів. Причина — одна рядка в специфікації, яку ніхто не уточнив.

Урок: «передавати навігаційні дані» — не вимога. «Передавати навігаційні дані у форматі SI (ньютон·секунд)» — вимога.

</details>

<details markdown="1">
<summary>Кейс: Heathrow Terminal 5 (день відкриття, 2008)</summary>

Система багажу не була протестована з реальним навантаженням. Вимога «система обробляє весь багаж аеропорту» не мала числового критерію — ні обсягу, ні часу обробки. У день відкриття система впала. Відправлено 500+ рейсів без багажу. 34,000 валіз загублено.

Урок: вимога без метрики — не вимога.

</details>

---

## 4. User Stories: вимоги мовою людини

User Story — формат запису вимоги, де в центрі стоїть користувач, а не система.

### Канонічний формат

```
Як [хто],
я хочу [що],
щоб [навіщо / яка цінність].
```

Приклад:
```
Як зареєстрований покупець,
я хочу зберегти товар у список бажань,
щоб повернутись до нього пізніше, коли з'являться кошти.
```

Ця структура змушує автора вимоги відповісти на три питання: хто користується функцією, що саме потрібно зробити, і чому взагалі це потрібно.

### Чому «чому» важливіше «що»

<details markdown="1">
<summary>Принцип Five Whys у вимогах</summary>

Замовник приходить із готовим рішенням: «Зробіть звіт у форматі Excel».

Якщо зупинитися тут — ви будете реалізувати Excel-звіт. Але якщо запитати «чому?»:

> Чому Excel? — Щоб передавати дані в бухгалтерію.
> Чому бухгалтерія не бере дані напряму? — У них інша система.
> Яка система? — SAP.
> SAP підтримує прямий API? — Так, і це вдвічі дешевше.

Реальна вимога: «Забезпечити передачу даних у бухгалтерську систему SAP». Рішення — прямий API. Excel нікому не потрібен.

Якщо реалізувати «що» без розуміння «чому» — ви ризикуєте зробити непотрібне правильно.

</details>

### Антипатерн: технічні User Stories

Погана User Story:
```
Як розробник,
я хочу рефакторити модуль авторизації,
щоб код був чистішим.
```

Це не User Story. Це технічна задача. User Story описує потребу користувача продукту, а не потребу команди. Технічні задачі записуються окремо — як Technical Debt або Engineering Task.

---

## 5. Acceptance Criteria: як ми знаємо, що вимога виконана

Acceptance Criteria (AC) — набір умов, при виконанні яких User Story вважається завершеною. Це не тести (хоча тести з них випливають). Це договір між PO і Dev.

### Формат: Given / When / Then

```
Given [стан системи / передумова],
When [дія користувача],
Then [очікуваний результат].
```

Приклад для User Story «зберегти товар у список бажань»:

```
Given: користувач авторизований і переглядає сторінку товару
When: натискає кнопку «Додати до бажань»
Then: товар з'являється у розділі «Мої бажання» без перезавантаження сторінки,
      лічильник бажань у хедері збільшується на 1,
      повторне натискання видаляє товар зі списку.
```

### Скільки Acceptance Criteria на одну User Story?

Практичне правило: від 3 до 7. Якщо більше 7 — скоріш за все, User Story занадто велика і її треба розбити.

---

## 6. INVEST: критерії якості User Story

INVEST — абревіатура, якою перевіряють User Story перед тим, як взяти її в Sprint.

| Літера | Принцип | Що означає |
| :--- | :--- | :--- |
| I | Independent | Не залежить від інших сторій (можна реалізувати окремо) |
| N | Negotiable | Не контракт. PO і Dev можуть домовитися про деталі |
| V | Valuable | Дає цінність користувачеві або бізнесу |
| E | Estimable | Команда може оцінити трудомісткість |
| S | Small | Виконується за один Sprint |
| T | Testable | Можна написати AC і перевірити |

<details markdown="1">
<summary>Як використовувати INVEST на практиці</summary>

Перед Sprint Planning кожна User Story проходить «INVEST-check». Якщо вона не відповідає хоча б одному критерію — повертається до PO на доопрацювання.

Найчастіше порушується S (Small): сторія виявляється занадто великою, щоб закрити за спринт. Рішення — вертикальне порізання (Vertical Slicing): замість «Реалізувати весь модуль оплати» робимо «Реалізувати оплату карткою Visa для замовлень до 10,000 грн».

</details>

---

## 7. Декомпозиція вимог: від Epic до Task

Вимоги в реальних проєктах існують на кількох рівнях абстракції.

```
Epic (Епік)
  └── Feature (Функціональність)
        └── User Story (Сторія)
              └── Task (Задача)
                    └── Sub-Task (Підзадача)
```

**Epic** — велика бізнес-мета. «Онлайн-замовлення їжі». Займає кілька спринтів або місяців.

**Feature** — конкретна функціональність. «Додати до кошика». Кілька тижнів.

**User Story** — одина поведінка одного користувача. «Додати товар до кошика з карткою товару». Один Sprint.

**Task** — технічна підзадача. «Реалізувати POST /cart endpoint». Кілька годин.

### Вертикальне і горизонтальне порізання

<details markdown="1">
<summary>Чому горизонтальне порізання — пастка</summary>

Горизонтальне порізання: ділимо роботу за шарами системи.

```
Sprint 1: Весь Backend для кошика
Sprint 2: Весь Frontend для кошика
Sprint 3: Весь QA для кошика
```

Результат: після 3 спринтів — нічого показати замовнику. Жоден шматок не є робочим самостійно.

Вертикальне порізання: ділимо по фічах, кожна з яких проходить всі шари.

```
Sprint 1: Додати товар до кошика (Backend + Frontend + QA)
Sprint 2: Видалити товар з кошика
Sprint 3: Змінити кількість товару
```

Результат: після кожного спринту є щось живе, що можна показати і отримати фідбек.

</details>

---

## 8. Приховані вимоги та правильні питання

Частина вимог ніколи не стоїть у ТЗ — замовник вважає їх очевидними. Але для розробника вони не очевидні.

### Типові «невидимі» вимоги, про які ніхто не говорить

| Категорія | Типова «невидима» вимога | Чому не скажуть самі |
| :--- | :--- | :--- |
| Браузери | «Сайт має працювати в IE 11» | Здається очевидним, але це 2026 — значить, не очевидно |
| Мови | «Інтерфейс українською і польською» | Замовник сам говорить обома, не подумав уточнити |
| Ролі | «Адміністратор бачить все; менеджер — лише свій регіон» | Розробник не знає бізнес-структуру компанії |
| Дані | «Старі дані з Excel потрібно мігрувати» | Замовник думав, що це не ваша задача |
| Доступність | «Сайт має відкриватися за 2 секунди» | Ніколи не скаже першим |

### Контрольні питання перед стартом розробки

Перед написанням першого рядка коду задайте замовникові:

1. Хто буде користуватись системою? (Роль, технічний рівень, кількість)
2. Якими пристроями? (Desktop, Mobile, планшет)
3. В яких умовах? (Офіс з хорошим інтернетом? Поле зі слабким сигналом?)
4. Що не повинна робити система? (Negative scope — часто важливіший за позитивний)
5. Що вважається успіхом через 6 місяців? (KPI приймання)

---

## 9. Інженерний insight: вимоги і теорія множин

<details markdown="1">
<summary>Формальний погляд для прикладних математиків</summary>

Систему вимог можна описати як три непересічні множини:

$$FR \cup NFR \cup C = \text{Специфікація}$$

де:
- $FR$ — Functional Requirements (що система робить)
- $NFR$ — Non-Functional Requirements (як система це робить: швидкість, надійність, безпека — наступна лекція)
- $C$ — Constraints (обмеження: бюджет, терміни, регуляторні вимоги)

Типова помилка команди: $FR \cap NFR \neq \emptyset$ — функціональну вимогу формулюють так, що вона містить нефункціональну. Наприклад: «Система має обробляти замовлення швидко» — це одночасно FR (обробляти замовлення) і NFR («швидко»). Їх треба розділити:

- $FR$: Система приймає та зберігає замовлення.
- $NFR$: Час відповіді на запит збереження замовлення — не більше 500мс при навантаженні 1,000 RPS.

Чому це важливо на практиці: $FR$ реалізує Dev, $NFR$ визначає Architect до початку розробки. Якщо вони змішані — ніхто не відповідає за перфоманс.

</details>

---

## 10. BACCM: модель бізнес-аналізу

BACCM (Business Analysis Core Concept Model) — фундаментальна модель, що описує шість ключових понять бізнес-аналізу. Всі шість взаємопов'язані: зміна одного впливає на решту.

```
         ┌─────────────────────┐
         │   Business Need     │  ← Проблема або можливість, що вимагає змін
         └──────────┬──────────┘
                    │ визначає
         ┌──────────▼──────────┐
         │       Change        │  ← Перехід від поточного стану до бажаного
         └──────────┬──────────┘
                    │ реалізується через
         ┌──────────▼──────────┐
         │      Solution       │  ← Продукт, сервіс або зміна процесу
         └──────────┬──────────┘
                    │ впливає на
 ┌──────────────────┼──────────────────┐
 │                  │                  │
 ▼                  ▼                  ▼
Stakeholders      Value             Context
(Стейкхолдери)   (Цінність)        (Контекст)
```

| Концепція | Визначення | Питання, яке ставить BA |
| :--- | :--- | :--- |
| **Business Need** | Проблема або можливість, що вимагає реакції | «Що не так? Чому зараз?» |
| **Change** | Будь-яка трансформація від поточного до бажаного стану | «Що саме змінюємо?» |
| **Solution** | Відповідь на потребу: продукт, процес, сервіс | «Як вирішуємо?» |
| **Stakeholder** | Будь-хто, хто впливає на рішення або відчуває його наслідки | «Хто бере участь / хто постраждає?» |
| **Value** | Цінність, яку отримають стейкхолдери від рішення | «Що виграємо?» |
| **Context** | Умови, обмеження та середовище, в якому існує зміна | «В яких умовах це живе?» |

### Чому BACCM важлива на практиці

Класична помилка джуніора: команда починає «рішення» (Solution), не визначивши «потребу» (Business Need). Через 3 місяці з'ясовується, що будували не те.

BACCM каже: спочатку зрозумій **потребу** і **контекст**, потім визнач **зміну**, потім обирай **рішення** і оцінюй **цінність** для всіх **стейкхолдерів**.

<details markdown="1">
<summary>Приклад: BACCM для системи онлайн-запису до лікаря</summary>

- **Business Need:** 70% дзвінків у реєстратуру — запис до лікаря. Реєстратори перевантажені, пацієнти чекають по 20 хвилин.
- **Change:** Перейти від телефонного запису до самостійного онлайн-запису.
- **Solution:** Веб-форма та мобільний застосунок для запису з інтеграцією в розклад лікарів.
- **Stakeholders:** Пацієнти, лікарі, реєстратори, ІТ-відділ, керівництво.
- **Value:** Пацієнти записуються за 2 хвилини 24/7. Реєстратори звільняються для складних питань. -30% операційних витрат.
- **Context:** Державна лікарня, обмежений ІТ-бюджет, частина пацієнтів — люди похилого віку без смартфонів.

Ключовий висновок з контексту: система має підтримувати і телефонний запис — не можна прибрати стару систему повністю.

</details>

---

## 11. Екзаменаційний пул (Exam Questions)

**Питання 1: Чим User Story відрізняється від технічного завдання?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

User Story описує потребу конкретного користувача і бізнес-цінність («Як покупець, я хочу зберегти товар»). Вона не диктує рішення.

Технічне завдання описує реалізацію («Реалізувати таблицю `wishlists` в PostgreSQL, REST endpoint POST /wishlist»). Воно говорить «як», а не «навіщо».

User Story — це «що і для кого». ТЗ — це «як реалізувати».

</details>

**Питання 2: Що таке Acceptance Criteria і навіщо вони потрібні?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

Acceptance Criteria — набір конкретних умов (у форматі Given/When/Then або звичайного списку), при виконанні яких User Story вважається завершеною. Це договір між PO і Dev: PO погоджує умови до старту розробки, Dev їх виконує, QA — перевіряє.

Без AC Dev і PO розуміють «готово» по-різному. AC усуває цю неоднозначність і дає тестувальнику чіткий набір тест-кейсів.

</details>

**Питання 3: Поясніть принцип «вертикального порізання» User Stories. Чому горизонтальне поділення — антипатерн?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

Горизонтальне поділення: Backend → Frontend → QA в окремих ітераціях. Після кожної ітерації немає робочого функціоналу.

Вертикальне: кожна User Story проходить усі шари від Backend до QA в одному Sprint. Після кожного Sprint є щось, що можна показати замовнику і отримати зворотний зв'язок.

Agile будується на ранньому зворотному зв'язку. Горизонтальне поділення відкладає його до «кінця» — коли виправляти вже дорого.

</details>

**Питання 4: Наведіть приклад «невидимої» вимоги і поясніть, чому замовник не говорить про неї сам.**

<details markdown="1">
<summary>Еталонна відповідь</summary>

Приклад: «Сайт має відкриватись за 2 секунди при навантаженні 500 одночасних користувачів».

Замовник не говорить про це сам, бо вважає очевидним: «Це ж сайт, він мусить бути швидким». Але «швидко» без цифр — не вимога. Без конкретних метрик розробник не знає, чи потрібен кеш, CDN, або достатньо стандартного підходу.

Саме тому інженер зобов'язаний ставити питання: «Скільки користувачів одночасно? За скільки секунд має відкриватись? Що станеться, якщо система не витримає?»

</details>

**Питання 5: Що таке INVEST і як критерій «Valuable» відрізняє User Story від технічної задачі?**

<details markdown="1">
<summary>Еталонна відповідь</summary>

INVEST — набір критеріїв якості User Story: Independent, Negotiable, Valuable, Estimable, Small, Testable.

Valuable означає, що Story дає пряму цінність кінцевому користувачеві або бізнесу. «Рефакторити модуль кошика» — не Valuable для користувача (він не помітить). Тому це не User Story, а Engineering Task. User Story: «Збільшити швидкість оформлення замовлення, щоб клієнт проходив весь шлях менш ніж за 3 хвилини».

</details>

---

**[⬅️ Лекція 2: Delivery Methodology](02_delivery_methodology.md)** | **[Лекція 4: NFRs ➡️](04_nfr.md)**

**[⬅️ Повернутися до головного меню курсу](index.md)**
