# Case Study: Чому CAP-теорема — це (майже) міф. Погляд Інженера vs Науковця

> **English version:** [English](en/case_study_cap.md)

**Джерела:**

1. **Marc Brooker (Principal Engineer at AWS):** "Let's Consign CAP to the Cabinet of Curiosities".
2. **Martin Kleppmann (University of Cambridge):** "Please stop calling databases CP or AP", автор книги "Designing Data-Intensive Applications".

**Рівень:** Advanced / Architecture Mindset.

---

## 1. Контекст: Що вам розказують в університеті?

На співбесідах і в підручниках ви чуєте мантру **CAP-теореми** (Brewer’s Theorem):

> *"У розподіленій системі неможливо одночасно гарантувати всі три властивості: **C**onsistency (Узгодженість), **A**vailability (Доступність) та **P**artition Tolerance (Стійкість до поділу). Виберіть два."*

Зазвичай це подається як жорсткий інженерний вирок та класифікація баз даних:

* **CP (жертвують доступністю):** PostgreSQL, MongoDB (вважається, що вони "ляжуть" або стануть read-only при збої мережі).
* **AP (жертвують даними):** Cassandra, DynamoDB (завжди відповідають, але можуть віддати старі дані — Eventual Consistency).

**Інженерна реальність:** Це **хибна дихотомія** для 99% сучасних веб-сервісів.

---

## 2. Погляд Інженера: Хмара «чітерить» (Marc Brooker, AWS)

Марк Брукер, людина, яка будує хмару AWS, стверджує: **"CAP-теорема неактуальна для більшості інженерів, які будують системи в хмарі"**.

### Чому? (Аргументація)

#### А. Хмара "чітерить" з мережею

У теорії CAP "Partition" (P) — це ситуація, коли сервер А не бачить сервер Б.
У реальності (AWS Region, Google Cloud) мережа всередині дата-центру настільки надійна і надлишкова (redundant), що "чисті" partitions трапляються вкрай рідко.

#### Б. Інфраструктура вирішує проблему за вас

Що відбувається, коли "відвалюється" ціла Availability Zone (один дата-центр)?

1. **Load Balancer (LB)** бачить, що зона "мертва" (Health Check failed).
2. LB миттєво перемикає трафік на іншу зону, де є копії (replicas) вашого сервісу.
3. **Клієнт:** Отримує відповідь (Available) і актуальні дані з репліки (Consistent).
4. **Висновок:** Для клієнта система є **CA** (і доступна, і узгоджена). Проблема "P" вирішена на рівні інфраструктури, а не коду.

#### В. Підміна понять

* **CAP-Available:** "Кожен живий вузол повинен відповісти". Навіть той, що відрізаний від бази даних.
* **Engineering-Available:** "Користувач може купити товар".
Якщо ми відключимо "відрізаний" вузол від трафіку (через Load Balancer), ми порушимо формальну CAP-доступність, але забезпечимо **реальну бізнес-доступність**.

---

## 3. [Deep Dive] Погляд Науковця: Пастка визначень (Martin Kleppmann)

Мартін Клеппман доводить, що CAP-теорема не просто "неактуальна", а її визначення часто вводять в оману.

1. **Consistency (C) = Linearizability.** Це НЕ цілісність даних (ACID). Це вимога, щоб система поводилася як *одна змінна*: запис завершено — будь-яке наступне читання ПОВИННО повернути нове значення миттєво. Більшість баз (Postgres, Oracle) за замовчуванням цього не гарантують (через snapshot isolation тощо), отже, вони формально не є "C" за CAP.
2. **Availability (A) = Total Availability.** Вимога, щоб *кожен* живий вузол обробив запит, навіть будучи ізольованим. У Master-Slave архітектурах ви не можете писати на Slave, якщо Master впав. Отже, вони формально не є "A".
3. **Partition Tolerance (P) = Asynchronous Network.** Це не вибір, а реальність. Мережа буде губити пакети, тому "вибрати CA" неможливо — не буває ідеальних мереж.

**Вирок:** Популярні бази не є ні CP, ні AP. Вони просто **P** (або "жодне з трьох"). Навіть "AP" бази (Cassandra) можуть стати недоступними, якщо не зберуть кворум під час розриву мережі.

---

## 4. Справжні компроміси (PACELC)

Якщо CAP не дає повної картини, про що має думати Архітектор?
Брукер пропонує фокусуватися на теоремі **PACELC** (розширення CAP) та фізичних метриках.

* **Якщо є Partition (P):** Вибір між Availability (A) та Consistency (C).
* **Else (E — коли мережа працює):** Вибір між **L**atency (затримка) та **C**onsistency (узгодженість).

### 1. Latency vs Consistency (Затримка проти Узгодженості)

Це найголовніший вибір у штатному режимі роботи.

* **Сценарій:** Ви пишете коментар.
* **Strong Consistency:** Ми чекаємо, поки коментар запишеться в 3 дата-центри (Київ, Франкфурт, Лондон). Це надійно, але довго (**Latency 200ms+**).
* **Eventual Consistency:** Ми пишемо в один (Київ) і віддаємо "ОК". Реплікація йде фоном. Це швидко (**Latency 20ms**), але якщо Київ згорить через 10мс — коментар зникне.

### 2. Durability vs Latency (Надійність зберігання проти Швидкості)

* Чи пишемо ми на диск (fsync) кожен запит? (Безпечно, повільно).
* Чи пишемо в пам'ять (Redis) і раз на секунду на диск? (Швидко, ризик втрати 1с даних).

---

## 5. FinOps: Ціна "вирішення" CAP (Hidden Costs)

У хмарі ви можете отримати і **Consistency**, і **Availability**. Але це коштує грошей. Щоб система виглядала для клієнта як **CA**, ви платите "податок на страх".

### 1. Податок на Надлишковість (Redundancy Tax)

Щоб пережити падіння зони (Partition Tolerance), ви повинні тримати копії.

* **Сценарій:** Ви використовуєте AWS RDS Multi-AZ.
* **Реальність:** Ви платите за **два** сервери (Primary + Standby).
* **Ефективність:** Standby сервер не обробляє трафік. Він просто "гріє повітря", чекаючи аварії.
* **Переплата: 100%**. Ви платите подвійну ціну за той самий performance.

### 2. Податок на Мережу (Cross-AZ Traffic Cost)

Узгодженість (Consistency) вимагає реплікації даних.

* **Фізика:** Щоб дані були надійними, ви пишете їх синхронно в Зону А і Зону Б.
* **FinOps:** У хмарах трафік *всередині* зони безкоштовний. Трафік *між* зонами — платний (~$0.01/GB).
* **Наслідок:** Якщо у вас High-Load база даних з інтенсивним записом, вартість реплікації (Cross-AZ traffic) може складати **до 30% всього чеку** за інфраструктуру. Ви платите за кожен байт консистентності.

### 3. Податок на Глобальність (Global Tables)

Якщо ви хочете "обманути" CAP на рівні планети (Low Latency + Strong Consistency у всьому світі), ви берете DynamoDB Global Tables або Google Spanner.

* **Механіка:** "Write locally, replicate globally".
* **Математика:** Якщо у вас 3 регіони, один запис коштує як **5 записів** (1 оригінал + 2 реплікації + 2 трафіку між регіонами).

> **Інженерний висновок:**
> CAP-теорема у хмарі трансформується у фінансове рівняння:
> **Availability + Consistency = $$$.**
> Питання не в тому "чи можливо це", а в тому "чи готовий бізнес за це платити".

---

## 6. Висновки для вашого проєкту (Engineering Takeaways)

1. **Не починайте дизайн з CAP.** Не кажіть "Ми будуємо AP систему". Це маркер джуніора.
2. **Термінологічна гігієна.** Кажіть: "Ми використовуємо Eventual Consistency для зниження Latency".
3. **Думайте про режими відмови.** Питайте, що зробить Load Balancer при падінні зони (Brooker) та що бачить клієнт, підключений до старого лідера (Kleppmann).
4. **Бізнес-метрики (Latency).** Питайте бізнес: "Чи готові ви чекати 500мс на кнопку 'Купити', щоб гарантувати, що ми ніколи не продамо зайвий квиток?".
5. **Де CAP все ще жива?**
* **IoT / Mobile:** Ваш телефон у метро (без мережі). Тут ви **змушені** вибирати: дати користувачу писати нотатки офлайн (AP, можливі конфлікти) чи заблокувати екран (CP).
* **Blockchain:** Тут Partition — це норма життя.



---

## 7. Завдання для обговорення (Discussion)

**Кейс 1: "Кошик товарів" (Rozetka/Amazon)**
Клієнт додає товар у кошик, їдучи в ліфті (інтернет зникає).

1. Яку стратегію ви оберете згідно з CAP? (AP чи CP?)
2. Як вирішити конфлікт (Merge), якщо клієнт додав товар на телефоні (офлайн), а потім видалили його з ноутбука (онлайн), і телефон відновив зв'язок?

**Кейс 2: PostgreSQL з асинхронною реплікацією**
Багато хто називає таку схему "CP". Чому Клеппман з цим не згоден?

<details>
<summary>Відповідь Архітектора</summary>

**По Кейсу 1 (Кошик):**

1. **Вибір:** Однозначно **AP (Availability)**. Бізнес ніколи не дозволить блокувати кнопку "Купити" через поганий інтернет. Гроші важливіші за ідеальну узгодженість.
2. **Merge Strategy:** Використати **"Union"** (об'єднання). Краще відновити видалений товар і дати користувачу видалити його ще раз, ніж випадково видалити те, що він хотів купити.

**По Кейсу 2 (Postgres):**

1. Це не **C** (Linearizability), бо читання з репліки може повернути старі дані (клієнт бачить "минуле").
2. Це не **A**, бо при падінні майстра система тимчасово не приймає записи (downtime на час перемикання failover).
3. **Вердикт:** Це система з певним рівнем надійності, яка не вписується в жорсткі рамки CAP.

</details>
