# Лекція 6: Подорож у світ паралельних обчислень

## Вступ

Привіт усім\! Сьогодні ми говоримо про одну з найпотужніших, але й найскладніших тем у Java — багатопотоковість. Наша мета — не просто завчити визначення, а зрозуміти, *чому* це важливо і *як* це працює "під капотом" сучасного заліза.

-----

## Навіщо нам усе це? Продуктивність та відгукливість

Уявіть, що ви користуєтеся програмою: клікаєте на кнопку, і весь інтерфейс "зависає" на 10 секунд, поки йде складне обчислення або завантаження даних. Неприємно, правда? Багатопотоковість дозволяє виконувати такі важкі задачі у фоні, залишаючи інтерфейс програми відгукливим.

Друга причина — швидкість. Сучасні комп'ютери не стільки збільшують тактову частоту одного ядра, скільки додають нові ядра. Щоб змусити вашу програму працювати швидше, потрібно навчитися ефективно використовувати їх усі одночасно.

-----

## Як працюють сучасні процесори?

Щоб зрозуміти паралелізм, давайте заглянемо всередину процесора (CPU).

Сучасний процесор має декілька **ядер** (Cores). Кожне ядро — це, по суті, самостійний обчислювальний блок. Якщо у вас 4-ядерний процесор, він може одночасно виконувати чотири різні задачі.

Але це ще не все. Більшість сучасних ядер підтримують технологію **Hyper-Threading** (або аналогічну). Це означає, що одне фізичне ядро може представлятися операційній системі як два логічних ядра. Кожне таке логічне ядро може виконувати свій **потік** (Thread) інструкцій.

**Кеші (L1, L2, L3):** Щоб не звертатися постійно до повільної оперативної пам'яті (Main Memory), процесори мають власну надшвидку пам'ять — кеш.

  * **L1 Cache:** Найшвидший і найменший, індивідуальний для кожного ядра. Розділяється на кеш інструкцій та кеш даних.
  * **L2 Cache:** Більший за об'ємом, але трохи повільніший. Також зазвичай індивідуальний для ядра.
  * **L3 Cache:** Найбільший і "найповільніший" з кешів, спільний для всіх ядер процесора.

Коли Java-програма створює потік, віртуальна машина (JVM) разом з операційною системою "призначає" цей потік на одне з доступних логічних ядер для виконання. І саме тут починається магія паралелізму.

![Іллюстрація організації пам'яті на процессорах](attachments/06_memory_hierarchy.png)

### Переваги (Benefits)

Використання багатопотоковості в Java надає кілька ключових переваг для розробки програмного забезпечення:

* **Покращена продуктивність:** Програми можуть працювати значно швидше, оскільки різні їх частини виконуються одночасно на кількох ядрах процесора.
* **Ефективне використання ресурсів:** Додатки можуть краще задіювати доступне апаратне забезпечення, що особливо важливо для інтенсивних завдань, як-от обробка відео чи наукові обчислення.
* **Підвищена відгукливість:** Дозволяє виконувати довготривалі операції (наприклад, роботу з мережею чи диском) у фоновому режимі, завдяки чому інтерфейс користувача не "зависає" і залишається активним.
* **Масштабованість:** Додатки, спроєктовані для багатопотоковості, легше масштабувати, особливо в хмарних середовищах, де ресурси можна додавати динамічно.

---

### Недоліки (Drawbacks)

Попри переваги, розробка багатопотокових додатків пов'язана зі значними викликами:

* **Складність розробки:** Написання коректного багатопотокового коду є складним завданням. Такі проблеми, як **взаємні блокування (deadlocks)**, **стани гонитви (race conditions)** та **ресурсне голодування (starvation)**, можуть призвести до непередбачуваної поведінки програми.
* **Підвищене споживання ресурсів:** Хоча багатопотоковість покращує продуктивність, вона також може призводити до більшого використання пам'яті та ресурсів процесора.
* **Складність налагодження (Debugging):** Виявлення та виправлення помилок у багатопотокових програмах є значно складнішим, оскільки проблеми можуть виникати нерегулярно і залежати від timing-у виконання потоків.
* **Накладні витрати на блокування:** Механізми синхронізації, необхідні для запобігання конфліктам даних, можуть створювати "вузькі місця", де потоки змушені простоювати, очікуючи на звільнення блокувань, що знижує переваги паралелізму.
* **Неправильне використання пулів потоків:** Некоректне налаштування пулів потоків (наприклад, занадто велика або мала кількість) може призвести до зниження продуктивності або вичерпання ресурсів системи.

-----

## Що таке потік у Java?

У Java потік — це найменша одиниця виконання коду.

-----

## Створення та запуск потоків: `Runnable` vs `Thread`

Історично в Java є два способи створити потік:

1.  Успадкувати клас `Thread`.
2.  Реалізувати інтерфейс `Runnable`.

Сьогодні **рекомендованим підходом є реалізація `Runnable`**. Це гнучкіше: ваш клас може успадковувати інший корисний клас і при цьому виконуватися в окремому потоці.

Код, який має виконатися в новому потоці, розміщується в методі `run()`.

**Найважливіша помилка новачка: `run()` vs `start()`**

Завжди запускайте потік методом `start()`\!

  * `thread.start()`: Повідомляє JVM, що потрібно виділити новий потік і в ньому виконати метод `run()`.
  * `thread.run()`: Просто виконає код з методу `run()` у поточному, головному потоці. Ніякої паралельності не буде\!

<details\>
<summary\><b\>Приклад створення потоків¹</b\></summary\>

```java
package org.example;

// Класичний підхід через наслідування
class HelloThread extends Thread {
    public void run() {
        System.out.println("Hello from a thread!");
    }
}

// Сучасний підхід через Runnable
class HelloRunnable implements Runnable {
    public void run() {
        System.out.println("Hello from a Runnable!");
    }
}

public class Main {
    public static void main(String[] args) {
        // Запуск потоків
        new Thread(new HelloRunnable()).start();
        new HelloThread().start();
    }
}
```

</details\>

<details\>
<summary\><b\>Лямбда-синтаксис для `Runnable`²</b\></summary\>

```java
package org.example;

public class MyLambda {
    public static void main(String[] args) {
        Runnable runnable =
                () -> { System.out.println("Lambda Runnable running"); };
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```

</details\>

¹ `Main.java`
² `MyLambda.java`

-----

## Життєвий цикл потоку

Потік не просто "працює" або "не працює". Він проходить через декілька станів:
* **NEW:** Потік створено, але ще не запущено.
* **RUNNABLE:** Потік готовий до виконання або вже виконується, але очікує на виділення ресурсів планувальником.
* **BLOCKED:** Потік заблокований, оскільки очікує на звільнення монітора (замка), щоб увійти до `synchronized` блоку.
* **WAITING:** Потік нескінченно очікує, поки інший потік виконає певну дію.
* **TIMED_WAITING:** Потік очікує на дію іншого потоку, але не довше зазначеного проміжку часу.
* **TERMINATED:** Потік завершив своє виконання.

### Як потік рухається між станами?

Перехід між цими станами — це керований процес:

* Початковий перехід відбувається при виклику методу **`start()`**, який переводить потік зі стану **`NEW`** у **`RUNNABLE`**.
* У стані **`RUNNABLE`** потік може бути як готовим до роботи (`READY`), так і безпосередньо виконуватися (`RUNNING`). Цим процесом керує планувальник операційної системи, і програміст не може на нього прямо вплинути.
* Зі стану виконання потік може перейти в інші стани:
    * **`TIMED_WAITING`**: через виклик `sleep(time)`, `wait(time)` або `join(time)`. Потік повертається в `RUNNABLE`, коли час очікування спливає.
    * **`WAITING`**: через виклик `join()` або `wait()` без таймауту. Повернення в `RUNNABLE` відбувається після виклику `notify()` або `notifyAll()` іншим потоком.
    * **`BLOCKED`**: коли потік намагається увійти в `synchronized` блок, але монітор об'єкта зайнятий. Він повернеться в `RUNNABLE`, як тільки отримає доступ до монітора.
* Коли метод **`run()`** потоку завершує свою роботу, потік переходить у фінальний стан **`TERMINATED`**.

![Іллюстрація Thread lifecycle](attachments/06_thread_lifecycle.png)
-----

## Проблеми синхронізації: Mutex, Monitor, Semaphore

Коли кілька потоків одночасно намагаються змінити спільні дані, виникає хаос, відомий як **стан гонитви (race condition)**. Щоб його уникнути, потрібні механізми синхронізації.

#### Mutex (М'ютекс)
**М'ютекс (або замок)** — це спеціальний механізм для синхронізації потоків. Його назва походить від англійського **MUTual EXclusion (взаємне виключення)**, що ідеально описує його призначення. Він "прикріплений" до кожного об'єкта в Java, незалежно від того, чи це стандартний клас, чи створений вами.

Головна задача м'ютекса — гарантувати, що лише один потік одночасно може отримати доступ до об'єкта. Популярна аналогія з реального життя — це вбиральня: коли людина заходить у кабінку, вона замикає двері зсередини, і всі інші змушені чекати.

М'ютекс має кілька важливих особливостей:
* **Два стани:** Він може перебувати лише у двох станах: "заблоковано" (locked) та "незаблоковано" (unlocked). Це дозволяє проводити аналогії з булевими змінними (`true`/`false`) або бінарними числами (`0`/`1`).
* **Непряме керування:** Ви не можете керувати станом м'ютекса напряму. У Java немає механізму, який би дозволив програмісту явно взяти м'ютекс об'єкта і присвоїти йому потрібний стан.

![Іллюстрація Mutext in Real Life](attachments/06_mutex_in_real_life.png)

#### Monitor (Монітор)

У Java м'ютекси реалізовані через механізм **моніторів**. Монітор — це, по суті, надбудова над м'ютексом, яка дозволяє потокам не тільки блокувати доступ до ресурсу, а й взаємодіяти через методи `wait()`, `notify()` та `notifyAll()`. Найпростіший спосіб використати монітор — це ключове слово `synchronized`.

#### Розбір `MutexSample.java` та `AtomicInteger`

Давайте подивимось на приклад лічильника, який інкрементують два потоки.

<details\>
<summary\><b\>Приклад з лічильником³</b\></summary\>

```java
package org.example;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

class Counter {
    private AtomicInteger count = new AtomicInteger(0);
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        // lock.lock(); // Старий варіант з блокуванням
        try {
            // Атомарна операція: читання, інкремент і запис за один крок
            count.incrementAndGet();
        } finally {
          //  lock.unlock();
        }
    }

    public int getCount() {
        return count.get();
    }
}

public class MutexSample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();

        t1.join(); // Чекаємо завершення потоків
        t2.join();

        System.out.println("Final count: " + counter.getCount());
    }
}
```

</details\>

**Що тут змінилося і чому?**
Початкова проблема така: операція `count++` не є **атомарною**. Вона складається з трьох кроків: 1) прочитати значення, 2) збільшити його, 3) записати назад. Між цими кроками інший потік може втрутитися, що призведе до втрати даних.

1.  **Старий підхід (закоментований):** Використання `ReentrantLock`. Це надійний, але відносно "важкий" спосіб синхронізації.
2.  **Сучасний підхід:** Використання `AtomicInteger`. Класи з пакету `java.util.concurrent.atomic` надають "безблокувальні" (lock-free) альтернативи. Метод `incrementAndGet()` виконує інкремент як одну, неподільну (атомарну) операцію на рівні апаратного забезпечення. Це набагато ефективніше, ніж повноцінне блокування потоку, для простих операцій.

³ `MutexSample.java`

#### Semaphore (Семафор)

#### Semaphore (Семафор)
**Семафор** — це інструмент для синхронізації доступу до ресурсу, який використовує лічильник для керування доступом. [cite: 178, 179] Цей лічильник вказує, скільки потоків можуть одночасно отримати доступ до спільного ресурсу. 

При створенні семафора в конструктор можна передати два основні параметри: 
* `int permits` — початкове і максимальне значення лічильника.  Цей параметр визначає, скільки потоків можуть одночасно отримати дозвіл. 
* `boolean fair` — встановлює порядок, у якому потоки отримують доступ.  Якщо `true`, доступ надається в порядку черги (FIFO).  Якщо `false`, порядок визначається планувальником потоків. 

Основні методи для роботи з семафором:
* `semaphore.acquire()`: Потік запитує дозвіл.  Якщо лічильник > 0, дозвіл надається, а лічильник зменшується.  Інакше потік блокується.
* `semaphore.release()`: Потік повертає раніше отриманий дозвіл, збільшуючи лічильник. 

М'ютекс — це, по суті, семафор з одним дозволом (`new Semaphore(1)`). 

![Іллюстрація Semaphore](attachments/06_semaphore.png)

#### Проблема філософів, що обідають

Це класична задача, яка ілюструє проблеми **дедлоку (deadlock)** та **ресурсного голодування (starvation)**.

**Контекст:** Уявіть п'ять філософів за столом з п'ятьма виделками. Щоб поїсти, кожному потрібні дві виделки.
**Проблема (дедлок):** Що, як кожен філософ одночасно візьме ліву виделку? Усі виделки будуть зайняті, і кожен буде вічно чекати на праву. Ніхто не зможе поїсти — система "зависла".

У нашому прикладі ця проблема вирішується за допомогою семафора, який обмежує кількість філософів за столом.

<details\>
<summary\><b\>Приклад з філософами⁴</b\></summary\>

```java
// Philosopher.java
class Philosopher extends Thread {
    private Semaphore sem;
    private boolean full = false;
    private String name;
    // ... конструктор ...
    public void run() {
        try {
            if (!full) {
                sem.acquire();
                System.out.println(name + " takes a seat at the table");
                sleep(300);
                full = true;
                System.out.println(name + " has eaten! He leaves the table");
                sem.release();
                sleep(300);
            }
        } catch(InterruptedException e) { /* ... */ }
    }
}

// PhilosopherDining.java
public class PhilosopherDining {
    public static void main(String[] args) {
        Semaphore sem = new Semaphore(2); // Стіл на 2 місця
        new Philosopher(sem, "Socrates").start();
        new Philosopher(sem,"Plato").start();
        new Philosopher(sem,"Aristotle").start();
        new Philosopher(sem, "Thales").start();
        new Philosopher(sem, "Pythagoras").start();
    }
}
```

</details\>

⁴ `Philosopher.java`, `PhilosopherDining.java`

-----

## Методи управління потоками

  * `Thread.sleep(millis)`: Призупиняє поточний потік на вказаний час
  * `thread.join()`: Призупиняє поточний потік, доки не завершиться потік `thread`. Це спосіб дочекатися результату роботи іншого потоку.
  * `object.wait()`: Потік звільняє монітор об'єкта `object` і переходить у стан очікування.
  * `object.notify()`: "Будить" один випадковий потік, що чекає на моніторі цього об'єкта.
  * `object.notifyAll()`: "Будить" усі потоки, що чекають.

<details\>
<summary\><b\>Приклад `wait` та `notify`⁵</b\></summary\>

```java
package org.example;

public class WaitNotifyExample {
    public static void main(String[] args) {
        Object lock = new Object();

        Thread waiter = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Waiting thread is waiting...");
                    lock.wait(); // Засинає і відпускає замок
                    System.out.println("Waiting thread woke up!");
                } catch (InterruptedException e) { e.printStackTrace(); }
            }
        });

        Thread notifier = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Notifier thread is sending a signal.");
                lock.notify(); // Будить інший потік
                System.out.println("Notifier thread sent the signal.");
            }
        });

        waiter.start();
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
        notifier.start();
    }
}
```

</details\>

⁵ `WaitNotifyExample.java`

-----

## Потоки-демони (Daemon Threads)

Це фонові потоки, які не заважають завершенню роботи програми. Якщо всі звичайні (не-демони) потоки завершили роботу, JVM примусово зупинить усі потоки-демони і завершить програму. Типовий приклад — Garbage Collector.

-----

## Майбутнє: віртуальні потоки (Project Loom / Fibers)

Наостанок, варто згадати про **Fibers** (або віртуальні потоки), які з'явилися в нових версіях Java. Це справжня революція, яка змінює підходи до конкурентного програмування в Java.

-----

## Контрольні питання

1.  **Основи:**
      * Назвіть дві головні причини використання багатопотоковості в сучасних програмах.
      * У чому полягає ключова відмінність між викликом методу `thread.start()` та `thread.run()`?
2.  **Архітектура та "Залізо":**
      * Поясніть своїми словами, як наявність декількох ядер та кешів впливає на виконання багатопотокової програми.
3.  **Синхронізація:**
      * Що таке "стан гонитви" (race condition)?
      * У чому принципова різниця між м'ютексом та семафором?
      * Чому `AtomicInteger` часто є більш продуктивним рішенням, ніж блокування?
4.  **Взаємодія потоків:**
      * Яке завдання виконує метод `thread.join()`?
      * Поясніть механізм роботи методів `wait()` та `notify()`.
5.  **Класичні задачі та концепції:**
      * Опишіть суть проблеми "філософів, що обідають".
      * Що таке потік-демон (Daemon Thread)?