# Практикум: Вступ до Maven — Управління проєктом та збірка

## Що таке Maven і навіщо він потрібен?

**Maven** — це інструмент для автоматизації збірки проєктів та управління залежностями. Уявіть його як "проєктного менеджера" для вашого коду.

Його основні задачі:
* **Управління залежностями:** Maven автоматично завантажує всі сторонні бібліотеки (наприклад, JUnit для тестів), які потрібні вашому проєкту. Вам не потрібно шукати та завантажувати `.jar` файли вручну.
* **Автоматизація збірки:** Він знає, як правильно скомпілювати ваш код, запустити тести, запакувати проєкт у виконуваний `.jar` файл та багато іншого. Це гарантує, що проєкт збирається однаково на будь-якому комп'ютері.
* **Стандартизація структури:** Maven пропонує стандартну структуру папок, що робить будь-який Maven-проєкт знайомим та зрозумілим для інших розробників.

---

## Стандартна структура Maven-проєкту

Коли ви створюєте Maven-проєкт, він має чітку та стандартизовану структуру папок:

```
my-app/
├── pom.xml         \<-- Головний конфігураційний файл проєкту
└── src/
├── main/       \<-- Усе, що стосується основного коду додатку
│   ├── java/   \<-- Вихідний код на Java
│   │   └── com/
│   │       └── mycompany/
│   │           └── app/
│   │               └── App.java
│   └── resources/ \<-- Ресурсні файли (напр., конфігурація)
└── test/       \<-- Усе, що стосується тестів
├── java/   \<-- Код тестів
│   └── com/
│       └── mycompany/
│           └── app/
│               └── AppTest.java
└── resources/ \<-- Ресурсні файли для тестів

````

**Package Naming (Іменування пакетів):**
Коротко про іменування: пакети в Java прийнято називати за принципом **зворотного доменного імені**. Наприклад, якщо ваша компанія має сайт `bobocode.com`, то пакети будуть починатися з `com.bobocode`. Це допомагає уникнути конфліктів імен у великих проєктах.

---

## Основні команди Maven

Maven працює на основі **життєвого циклу збірки (build lifecycle)**, який складається з послідовних фаз. Ось найважливіші команди:

* **`mvn clean`**
    * **Що робить:** Видаляє результати попередньої збірки (зазвичай теку `target/`). Це корисно, щоб почати "з чистого аркуша".
* **`mvn compile`**
    * **Що робить:** Компілює вихідний код вашого проєкту (з `src/main/java`) у байт-код (`.class` файли) і складає їх у теку `target/classes`.
* **`mvn test`**
    * **Що робить:** Компілює та запускає всі тести (з `src/test/java`). Перед цим автоматично виконуються всі попередні фази, включаючи `compile`.
* **`mvn package`**
    * **Що робить:** Бере скомпільований код та ресурси і запаковує їх у фінальний артефакт, зазвичай у `.jar` файл, який розміщується в теці `target/`. Ця команда також запускає всі попередні фази, включаючи `test`.

---

## Як читати лог Maven (аналіз прикладу)

Розглянемо типовий вивід команди `mvn test`. Хоча він виглядає складним, його легко зрозуміти, якщо розбити на частини.

```bash
# 1. Ініціалізація та ідентифікація проєкту
/bin/sh ... mvn ... test ... # Команда, яку запустила ваша IDE
[INFO] Scanning for projects...
[INFO] -----------------------< com.bobocode:0-0-intro >----------------------- # Maven знайшов проєкт
[INFO] Building 0-0-intro 1.0-SNAPSHOT                                      # Починається збірка
[INFO] --------------------------------[ jar ]--------------------------------- # Тип артефакту, що збирається

# 2. Фаза обробки ресурсів
[INFO] --- resources:3.3.1:resources (default-resources) @ 0-0-intro ---      # Плагін для копіювання ресурсів
[INFO] skip non existing resourceDirectory .../src/main/resources             # Пропускає, бо тека пуста

# 3. Фаза компіляції основного коду
[INFO] --- compiler:3.11.0:compile (default-compile) @ 0-0-intro ---          # Плагін-компілятор
[INFO] Nothing to compile - all classes are up to date                        # Повідомляє, що код не змінювався

# 4. Фази обробки ресурсів та компіляції тестів
[INFO] --- resources:3.3.1:testResources ... ---                              # Копіювання ресурсів для тестів
[INFO] --- compiler:3.11.0:testCompile ... ---                                # Компіляція коду тестів
[INFO] Nothing to compile - all classes are up to date

# 5. Фаза запуску тестів
[INFO] --- surefire:3.1.2:test (default-test) @ 0-0-intro ---                 # Плагін Surefire для запуску тестів
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running com.bobocode.intro.ExerciseIntroductionTest                    # Запускає конкретний клас з тестами
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.164 s # Результат виконання тестів
[INFO]
[INFO] Results:
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0

# 6. Завершення
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS                                                          # Найважливіший рядок: збірка успішна!
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  3.199 s                                                   # Загальний час виконання
[INFO] Finished at: 2025-09-10T21:15:26+03:00
[INFO] ------------------------------------------------------------------------
````

**Головне:** Завжди шукайте рядок **`BUILD SUCCESS`** або **`BUILD FAILURE`**. Якщо сталася помилка, детальний опис буде трохи вище цього рядка.

-----

## Що таке Maven-модулі?

Уявіть великий проєкт, наприклад, інтернет-магазин. Він може складатися з кількох логічно відокремлених частин:

  * Модуль для роботи з користувачами (`user-service`).
  * Модуль для обробки замовлень (`order-service`).
  * Загальний модуль з утилітами (`common-utils`).

**Maven-модулі** дозволяють організувати такий проєкт як **багатомодульний (multi-module project)**.

  * **Структура:** У корені проєкту знаходиться головний (`parent`) `pom.xml`, який описує загальні залежності та перераховує всі під-модулі. Кожен модуль є окремою підтекою зі своїм власним `pom.xml`.
  * **Як з цим працювати:**
      * `mvn clean install` у **кореневій теці** збере та встановить всі модулі в правильному порядку.
      * Ви можете зайти в теку **конкретного модуля** (наприклад, `cd user-service`) і виконати команди (`mvn test`) тільки для нього.

Це робить роботу з великими проєктами набагато зручнішою та організованішою.

-----

Звісно, ось доповнення до лекції, яке рекомендує студентам використовувати підхід TDD у роботі з Maven.

Цей розділ найкраще додати перед секцією "Контрольні питання".

-----

## Рекомендація: Розробка через тестування (Test-Driven Development)

Для виконання практичних завдань на курсі я наполегливо рекомендую використовувати підхід **Test-Driven Development (TDD)** або "Розробка через тестування". Це процес, у якому ви пишете автоматизовані тести **до** написання основного коду.

Основний цикл TDD, відомий як **"Червоний – Зелений – Рефакторинг"**, ідеально лягає на роботу з Maven.

### ### Робочий процес TDD з Maven

#### Крок 1: (Червоний 🔴) — Напишіть тест, що падає
Перш ніж писати будь-який код у `src/main/java`, спочатку напишіть тест для нього у `src/test/java`, який перевіряє ще не реалізовану функціональність.

Тепер запустіть команду:
```bash
mvn test
````

**Результат:** Збірка завершиться з помилкою (**BUILD FAILURE**), оскільки тест не проходить. Це очікувана поведінка. Ви переконалися, що ваш тест справді перевіряє те, що потрібно.

#### Крок 2: (Зелений 🟢) — Напишіть мінімальний код, щоб тест пройшов

Тепер перейдіть до основного коду (`src/main/java`) і напишіть **мінімально необхідний** обсяг коду, щоб ваш тест почав проходити. Не намагайтеся зробити його ідеальним, головне — змусити тест "позеленіти".

Знову запустіть команду:

```bash
mvn test
```

**Результат:** Цього разу збірка має бути успішною (**BUILD SUCCESS**), і ви побачите, що ваші тести пройшли.

#### Крок 3: (Рефакторинг 🔵) — Покращіть код

Тепер, коли у вас є тест, що працює, і він захищає вас від помилок, ви можете спокійно покращувати ваш основний код: робити його чистішим, ефективнішим та читабельнішим (проводити рефакторинг). Після кожної зміни ви можете запускати `mvn test`, щоб переконатися, що нічого не зламали.

### \#\#\# Навіщо це потрібно?

  * **Впевненість:** Ви точно знаєте, що ваш код працює так, як очікується.
  * **Кращий дизайн:** Написання тестів змушує вас думати про те, як ваш код буде використовуватися, що веде до кращої архітектури.
  * **Безпечний рефакторинг:** Ви можете сміливо змінювати код, знаючи, що тести завжди підкажуть, якщо щось піде не так.


## Контрольні питання

1.  **Концепція.** Назвіть дві основні задачі, які вирішує Maven у проєкті.
2.  **Структура.** У якій теці за стандартом Maven має знаходитись вихідний код тестів?
3.  **Команди.** Ви внесли зміни у код і хочете переконатися, що все працює правильно, включаючи тести, та отримати готовий `.jar` файл. Яку одну команду Maven вам потрібно виконати?
4.  **Аналіз логів.** Який плагін Maven відповідає за запуск тестів, і який рядок у лозі свідчить про успішне завершення всього процесу збірки?